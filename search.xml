<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>革命性AI创新！一句话即可打造震撼120秒超长视频，免费开源，引爆你的创作激情！</title>
    <url>/article/112246.html</url>
    <content><![CDATA[<h1 id="欣赏AI生成的视频效果"><a href="#欣赏AI生成的视频效果" class="headerlink" title="欣赏AI生成的视频效果"></a>欣赏AI生成的视频效果</h1><p><img src="https://img.funning.top/ai-video-1.gif"></p>
<p>最新发布的StreamingT2V模型，由Picsart AI Research团队倾力打造，引领视频生成领域的革新！超越Sora模型，轻松创造长达2分钟（1200帧）的高品质视频！更令人振奋的是，<br>这一开源模型与SVD、animatediff等其他模型完美兼容，为视频生成领域带来了前所未有的突破！</p>
<p><img src="https://img.funning.top/ai-video-2.gif"></p>
<h1 id="亮点总结"><a href="#亮点总结" class="headerlink" title="亮点总结"></a>亮点总结</h1><ul>
<li>创造长达2分钟（1200帧）的视频，超越以往模型</li>
<li>视频质量卓越，呈现高品质效果</li>
<li>与其他主流模型实现无缝衔接，提供更多创作可能性</li>
<li>开源免费，方便开发者使用和进行二次开发</li>
</ul>
<h1 id="免费体验"><a href="#免费体验" class="headerlink" title="免费体验"></a>免费体验</h1><p>免费在线试玩：<a href="https://huggingface.co/spaces/PAIR/StreamingT2V">点击跳转</a></p>
<h1 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h1><ol>
<li><p>安装并安装 Python 3.10 and CUDA &gt;&#x3D; 11.6 环境 <a href="https://www.python.org/downloads/release/python-3100/">Python 3</a><br>、<a href="https://developer.nvidia.com/cuda-downloads">Cuda 下载</a></p>
</li>
<li><p>克隆开源项目至本地：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Picsart-AI-Research/StreamingT2V.git</span><br><span class="line">cd StreamingT2V/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装必备的环境：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n st2v python=3.10</span><br><span class="line">conda activate st2v</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>可选</code>如果您的系统上缺少 FFmpeg，请安装 FFmpeg</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install conda-forge::ffmpeg</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>从<a href="https://huggingface.co/PAIR/StreamingT2V">huggingface</a> 下载模型并将它放在 <code>t2v_enhanced/checkpoints</code> 目录下</p>
</li>
<li><p>文本转视频</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd t2v_enhanced</span><br><span class="line">python inference.py --prompt=&quot;A white bone spirit riding a motorcycle&quot;</span><br></pre></td></tr></table></figure>


<h1 id="基础模型推理时间对比"><a href="#基础模型推理时间对比" class="headerlink" title="基础模型推理时间对比"></a>基础模型推理时间对比</h1><h2 id="ModelscopeT2V作为基础模型"><a href="#ModelscopeT2V作为基础模型" class="headerlink" title="ModelscopeT2V作为基础模型"></a><a href="https://github.com/modelscope/modelscope">ModelscopeT2V</a>作为基础模型</h2><table>
<thead>
<tr>
<th align="center">帧数</th>
<th align="center">更快预览的推理时间 (256×256)</th>
<th align="center">最终结果的推理时间 (720×720)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">24帧</td>
<td align="center">40秒</td>
<td align="center">165秒</td>
</tr>
<tr>
<td align="center">56帧</td>
<td align="center">75秒</td>
<td align="center">360秒</td>
</tr>
<tr>
<td align="center">80帧</td>
<td align="center">110秒</td>
<td align="center">525秒</td>
</tr>
<tr>
<td align="center">240帧</td>
<td align="center">340秒</td>
<td align="center">1610 秒（约 27 分钟）</td>
</tr>
<tr>
<td align="center">600帧</td>
<td align="center">860秒</td>
<td align="center">5128 秒（约 85 分钟）</td>
</tr>
<tr>
<td align="center">1200帧</td>
<td align="center">1710 秒（约 28 分钟）</td>
<td align="center">10225 秒（约 170 分钟）</td>
</tr>
</tbody></table>
<h2 id="AnimateDiff作为基础模型"><a href="#AnimateDiff作为基础模型" class="headerlink" title="AnimateDiff作为基础模型"></a><a href="https://github.com/guoyww/AnimateDiff">AnimateDiff</a>作为基础模型</h2><table>
<thead>
<tr>
<th align="center">帧数</th>
<th align="center">更快预览的推理时间 (256×256)</th>
<th align="center">最终结果的推理时间 (720×720)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">24帧</td>
<td align="center">50秒</td>
<td align="center">180秒</td>
</tr>
<tr>
<td align="center">56帧</td>
<td align="center">85秒</td>
<td align="center">370秒</td>
</tr>
<tr>
<td align="center">80帧</td>
<td align="center">120秒</td>
<td align="center">535秒</td>
</tr>
<tr>
<td align="center">240帧</td>
<td align="center">350秒</td>
<td align="center">1620 秒（约 27 分钟）</td>
</tr>
<tr>
<td align="center">600帧</td>
<td align="center">870秒</td>
<td align="center">5138 秒（~85 分钟）</td>
</tr>
<tr>
<td align="center">1200帧</td>
<td align="center">1720 秒（约 28 分钟）</td>
<td align="center">10235 秒（约 170 分钟）</td>
</tr>
</tbody></table>
<h2 id="SVD作为基本模型"><a href="#SVD作为基本模型" class="headerlink" title="SVD作为基本模型"></a><a href="https://github.com/Stability-AI/generative-models">SVD</a>作为基本模型</h2><table>
<thead>
<tr>
<th align="center">帧数</th>
<th align="center">更快预览的推理时间 (256×256)</th>
<th align="center">最终结果的推理时间 (720×720)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">24帧</td>
<td align="center">80秒</td>
<td align="center">210秒</td>
</tr>
<tr>
<td align="center">56帧</td>
<td align="center">115秒</td>
<td align="center">400秒</td>
</tr>
<tr>
<td align="center">80帧</td>
<td align="center">150秒</td>
<td align="center">565秒</td>
</tr>
<tr>
<td align="center">240帧</td>
<td align="center">380秒</td>
<td align="center">1650 秒（约 27 分钟）</td>
</tr>
<tr>
<td align="center">600帧</td>
<td align="center">900秒</td>
<td align="center">5168 秒（~86 分钟）</td>
</tr>
<tr>
<td align="center">1200帧</td>
<td align="center">1750 秒（约 29 分钟）</td>
<td align="center">10265 秒（~171 分钟）</td>
</tr>
</tbody></table>
<p>所有测量均使用 NVIDIA A100 (80 GB) GPU 进行。当帧数超过 80 时，采用随机混合。对于随机混合，chunk_size和 的值overlap_size分别设置为 112 和 32。</p>
<p>更多的文生视频在线使用：<a href="https://huggingface.co/spaces/PAIR/Text2Video-Zero">点击前往</a> 支持多模型自由切换！</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>AI</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>【超级干货！】8个免费GPT-4网站！🤯立省$20不香吗？教你如何白嫖使用GPT-4🤖 | How to Access GPT-4 for Free!</title>
    <url>/article/112231.html</url>
    <content><![CDATA[<h2 id="8个能使用GPT-4的网站，带你领略人工智能的强大！"><a href="#8个能使用GPT-4的网站，带你领略人工智能的强大！" class="headerlink" title="8个能使用GPT-4的网站，带你领略人工智能的强大！"></a>8个能使用GPT-4的网站，带你领略人工智能的强大！</h2><p>GPT-4，由OpenAI开发的大型语言模型，拥有强大的文本生成、翻译、问答等能力，是人工智能领域的最新突破。</p>
<p>想要体验GPT-4的魅力，但苦于没有开发环境？别担心！这里为你推荐8个能使用GPT-4的网站，让你轻松感受人工智能的强大。</p>
<h3 id="merlin"><a href="#merlin" class="headerlink" title="merlin"></a>merlin</h3><blockquote>
<p>链接地址：<a href="https://www.getmerlin.in/fr">https://www.getmerlin.in/fr</a></p>
</blockquote>
<p>Merlin AI 的主要功能包括：</p>
<ul>
<li>文本生成：可以生成各种文本格式，例如诗歌、代码、剧本、音乐作品、电子邮件、信件等。</li>
<li>翻译：可以翻译多种语言，并且支持多种语言之间的互译。</li>
<li>问答：可以回答您的问题，即使是开放式、具有挑战性或奇怪的问题。</li>
</ul>
<p>Merlin AI 的优势包括：</p>
<ul>
<li>强大：拥有强大的语言理解和处理能力，可以完成各种复杂的任务。</li>
<li>灵活：可以根据您的需求进行调整，以满足您的特定需求。</li>
<li>易用：提供便捷的操作界面，即使没有编程经验，也能轻松使用。</li>
</ul>
<p>Merlin AI 的应用场景包括：</p>
<ul>
<li>写作：可以帮助您完成写作任务，例如写文章、写代码、写剧本等。</li>
<li>翻译：可以帮助您克服语言障碍，与来自不同国家的人交流。</li>
<li>学习：可以帮助您学习新知识，回答您的疑问。</li>
<li>娱乐：可以帮助您创作各种娱乐内容，例如诗歌、音乐、故事等。</li>
</ul>
<h4 id="merlin如何使用？"><a href="#merlin如何使用？" class="headerlink" title="merlin如何使用？"></a>merlin如何使用？</h4><p>首先进入链接，可以看到如下的界面，只需要安装一个插件即可。如果是edge浏览器，也是类似的不再赘述。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/Merlin1.png"></p>
<p>安装好之后，会出现在浏览器的右侧，点击就可以使用啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/Merlin2.png"></p>
<p>使用界面如下，可以上传pdf、doc、txt等文件，也可以生成图片等AI功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/Merlin3.png"></p>
<p>大模型的种类也是很多，像常见的google的gemini、chatgpt3.5、Llama-2模型应有尽有。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/Merlin4.png"></p>
<h2 id="perplexity"><a href="#perplexity" class="headerlink" title="perplexity"></a>perplexity</h2><blockquote>
<p>链接地址：<a href="https://www.perplexity.ai/">https://www.perplexity.ai</a></p>
</blockquote>
<p>Perplexity.AI 的主要功能包括：</p>
<ul>
<li>Pro Search：提供更强大的搜索功能，可以帮助您找到更准确、更相关的信息，还可以生成图片。(其实就是chatgpt-4)。</li>
<li>AI Assistant：提供个性化的 AI 助手，可以根据您的需求提供帮助。</li>
<li>API：提供 API 接口，可以将 Perplexity.AI 的功能集成到您的应用程序中。</li>
</ul>
<h4 id="perplexity如何使用？"><a href="#perplexity如何使用？" class="headerlink" title="perplexity如何使用？"></a>perplexity如何使用？</h4><p>点击链接进入即可使用，需切换成pro。<br><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/perplexity2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/perplexity1.png"></p>
<p>此外还可以在discover里看到当前最新的AI新闻。<br><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/perplexity3.png"></p>
<h2 id="copilot"><a href="#copilot" class="headerlink" title="copilot"></a>copilot</h2><blockquote>
<p>链接地址：<a href="https://www.microsoft.com/zh-cn/edge/features/copilot?form=MA13FJ">https://www.microsoft.com/zh-cn/edge/features/copilot?form=MA13FJ</a></p>
</blockquote>
<p>Copilot 是 GitHub 推出的一款 AI 辅助编程工具，可以帮助开发者提高编码效率。它基于 OpenAI 的 Codex 模型，可以理解代码并生成代码建议，初次之外还可以<strong>语音对话</strong>。</p>
<p>Copilot 的特殊功能包括：</p>
<ul>
<li>自动补全代码: Copilot 可以自动补全代码，包括函数、变量、类等。它还可以根据上下文生成代码建议，帮助开发者快速完成编码任务。</li>
<li>代码生成: Copilot 可以根据自然语言描述生成代码。例如，您可以输入“创建一个函数，将两个数字相加”，Copilot 会自动生成相应的代码。</li>
<li>代码解释: Copilot 可以解释代码的作用和用法。您可以将光标悬停在代码上，Copilot 会显示代码的解释。</li>
<li>代码修复: Copilot 可以帮助您修复代码错误。它可以识别代码错误并提供修复建议。</li>
<li>代码风格检查: Copilot 可以检查代码风格是否符合规范。它可以根据编码规范提出建议，帮助您提高代码质量。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/copilot.png"></p>
<h2 id="skype"><a href="#skype" class="headerlink" title="skype"></a>skype</h2><blockquote>
<p>链接地址：<a href="https://you.com/">https://you.com/</a></p>
</blockquote>
<p>拥有超强的反应速度和记忆力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/skype3.png"></p>
<h2 id="you-AI"><a href="#you-AI" class="headerlink" title="you AI"></a>you AI</h2><blockquote>
<p>链接地址：<a href="https://you.com/">https://you.com/</a></p>
</blockquote>
<p>每日有次使用机会，还是非常不错的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/you.png"> </p>
<h2 id="pop-AI"><a href="#pop-AI" class="headerlink" title="pop AI"></a>pop AI</h2><blockquote>
<p>链接地址：<a href="https://www.popai.pro/">https://www.popai.pro/</a></p>
</blockquote>
<p>可以生成PPT，可以上传文件，生成图片等功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/pop1.png"></p>
<h2 id="coze-AI"><a href="#coze-AI" class="headerlink" title="coze AI"></a>coze AI</h2><blockquote>
<p>链接地址：<a href="https://www.coze.com/">https://www.coze.com/</a></p>
</blockquote>
<p>这是一款字节旗下面向海外的AI。有非常非常多好玩的插件哦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/1137882300/images@master/images/coze.png"></p>
<h2 id="mychandler-AI"><a href="#mychandler-AI" class="headerlink" title="mychandler AI"></a>mychandler AI</h2><blockquote>
<p><a href="https://mychandler.bet/chat">https://mychandler.bet/chat</a></p>
</blockquote>
<p>不仅可以使用chatgpt-4，还能使用claude3</p>
<p><img src="https://img.funning.top/mychandler.png"></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>白嫖</category>
      </categories>
      <tags>
        <tag>chatgpt</tag>
        <tag>gpt-4</tag>
        <tag>gpt-3.5</tag>
      </tags>
  </entry>
  <entry>
    <title>META LLAMA 3 爆炸登场！在线试用、本地部署，性能直逼 GPT-4！</title>
    <url>/article/112247.html</url>
    <content><![CDATA[<h1 id="Meta-宣布推出革命性开源大语言模型-Llama-3！"><a href="#Meta-宣布推出革命性开源大语言模型-Llama-3！" class="headerlink" title="Meta 宣布推出革命性开源大语言模型 Llama 3！"></a>Meta 宣布推出革命性开源大语言模型 Llama 3！</h1><p>Meta 正式发布了下一代开源大语言模型 Llama 3，这标志着 AI 发展的新里程碑！该模型分为 80 亿和 700 亿参数两个版本，<br>被誉为“Llama 2 的重大飞跃”，为大规模语言模型树立新标杆。</p>
<h1 id="Llama-3-的未来之路"><a href="#Llama-3-的未来之路" class="headerlink" title="Llama 3 的未来之路"></a>Llama 3 的未来之路</h1><p>值得一提的是，Llama 3 已与 Meta AI 助手深度集成，未来还将陆续在 AWS、Databricks、Google Cloud 等多个云平台上线，<br>并获得AMD、Intel、NVIDIA 等硬件厂商的支持，进一步扩大应用场景。<br>这将为 Llama 3 带来无限的可能！</p>
<h1 id="Meta-的开源AI-决心"><a href="#Meta-的开源AI-决心" class="headerlink" title="Meta 的开源AI 决心"></a>Meta 的开源AI 决心</h1><p>该模型的发布彰显了 Meta 在开源 AI 领域的决心和影响力。我们有理由期待，Llama 3 将为自然语言处理、机器学习等 AI 前沿技术的发展注入新动力。<br>期待 Llama 3 的未来！</p>
<h1 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h1><ol>
<li>在线使用（<code>推荐</code>）</li>
<li>本地直连使用</li>
<li>套壳使用</li>
<li>API 方式调用（<code>推荐</code>）</li>
</ol>
<h2 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h2><p>入口：<a href="https://www.meta.ai/">链接直达</a></p>
<blockquote>
<p>不仅可以智能对话，也可以在线生成图片</p>
</blockquote>
<h2 id="本地直连使用"><a href="#本地直连使用" class="headerlink" title="本地直连使用"></a>本地直连使用</h2><ol>
<li><p>从github下载Llama 3 项目文件：<br><a href="https://github.com/meta-llama/llama3">点击下载</a></p>
</li>
<li><p>申请模型下载链接（申请秒过），申请后会在邮件里提供一个下载链接：<br><a href="https://llama.meta.com/llama-downloads/">点击申请</a></p>
</li>
<li><p>环境依赖安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Llama3最高级目录执行以下命令(建议在安装了python的conda环境下执行)</span></span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载Llama3模型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash download.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行命令后在终端下输入邮件里获取到下载链接，并选择你需要的模型</p>
</li>
<li><p>运行示例脚本，执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">torchrun --nproc_per_node 1 example_chat_completion.py \</span><br><span class="line">    --ckpt_dir Meta-Llama-3-8B-Instruct/ \</span><br><span class="line">    --tokenizer_path Meta-Llama-3-8B-Instruct/tokenizer.model \</span><br><span class="line">    --max_seq_len 512 --max_batch_size 6</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自己的对话脚本，在根目录下创建以下chat.py脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">from</span> llama <span class="keyword">import</span> Dialog, Llama</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"></span></span><br><span class="line"><span class="params">ckpt_dir: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">tokenizer_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">top_p: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span><br><span class="line"><span class="params">max_seq_len: <span class="built_in">int</span> = <span class="number">512</span>,</span></span><br><span class="line"><span class="params">max_batch_size: <span class="built_in">int</span> = <span class="number">4</span>,</span></span><br><span class="line"><span class="params">max_gen_len: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    generator = Llama.build(</span><br><span class="line">        ckpt_dir=ckpt_dir,</span><br><span class="line">        tokenizer_path=tokenizer_path,</span><br><span class="line">        max_seq_len=max_seq_len,</span><br><span class="line">        max_batch_size=max_batch_size,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Modify the dialogs list to only include user inputs</span></span><br><span class="line">    dialogs: <span class="type">List</span>[Dialog] = [</span><br><span class="line">        [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;&quot;</span>&#125;],  <span class="comment"># Initialize with an empty user input</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start the conversation loop</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Get user input</span></span><br><span class="line">        user_input = <span class="built_in">input</span>(<span class="string">&quot;You: &quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Exit loop if user inputs &#x27;exit&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> user_input.lower() == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Append user input to the dialogs list</span></span><br><span class="line">        dialogs[<span class="number">0</span>][<span class="number">0</span>][<span class="string">&quot;content&quot;</span>] = user_input</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use the generator to get model response</span></span><br><span class="line">        result = generator.chat_completion(</span><br><span class="line">            dialogs,</span><br><span class="line">            max_gen_len=max_gen_len,</span><br><span class="line">            temperature=temperature,</span><br><span class="line">            top_p=top_p,</span><br><span class="line">        )[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print model response</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Model: <span class="subst">&#123;result[<span class="string">&#x27;generation&#x27;</span>][<span class="string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"> fire.Fire(main)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令就可以开始对话</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">torchrun --nproc_per_node 1 chat.py     --ckpt_dir Meta-Llama-3-8B-Instruct/     --tokenizer_path Meta-Llama-3-8B-Instruct/tokenizer.model     --max_seq_len 512 --max_batch_size 6</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="套壳使用"><a href="#套壳使用" class="headerlink" title="套壳使用"></a>套壳使用</h2><ol>
<li><p>通过LM Studio 下载Llama 3 大模型<br><a href="https://lmstudio.ai/">点击下载</a></p>
</li>
<li><p>下载模型后通过Jan加载模型，就可以实现可视化操作使用！非常适合新手<br><a href="https://jan.ai/">点击下载</a></p>
<p><img src="https://img.funning.top/Snipaste_10.png" alt="使用截图"></p>
</li>
</ol>
<h2 id="API-方式调用"><a href="#API-方式调用" class="headerlink" title="API 方式调用"></a>API 方式调用</h2><ol>
<li><p>免费申请 Groq 的 API KEY<br><a href="https://groq.com/">点击申请</a></p>
</li>
<li><p>部署lobe-chat<br><a href="https://github.com/lobehub/lobe-chat">点击查看部署步骤</a></p>
</li>
<li><p>部署好之后来到：设置-语言模型-groq<br><img src="https://img.funning.top/lobe02.png" alt="设置图片"></p>
</li>
<li><p>最后免费无限享受😎<br><img src="https://img.funning.top/lobe01.png" alt="使用截图"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>一键部署Google开源大模型Gemma，性能远超Mistral、LLama2 | 本地大模型部署，ollama助您轻松完成！</title>
    <url>/article/112235.html</url>
    <content><![CDATA[<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><blockquote>
<p>安装相关软件</p>
</blockquote>
<ul>
<li><code>docker</code> 下载安装，地址： <a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a></li>
</ul>
<p><img src="https://img.funning.top/docker-download.png"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Docker 是一种开源平台，用于开发、交付和运行应用程序。它利用容器化技术，可以将应用程序及其所有依赖项打包到一个独立的、标准化的单元中，称为容器。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ollama</code> 下载安装，地址： <a href="https://ollama.com/download">https://ollama.com/download</a></li>
</ul>
<p><img src="https://img.funning.top/ollama-download.png"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ollama 简单理解就是 安装、管理、连接 大模型的门户工具</span><br></pre></td></tr></table></figure>

<h1 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h1><blockquote>
<p>选择性操作</p>
</blockquote>
<p>终端执行命令</p>
<p>启动ollama：<code>ollama serve</code> （默认情况下下载好就是启动状态的）</p>
<p>安装大模型：gemma:2b版：<code>ollama run gemma:2b</code><br>(安装过程有点慢，耐心等待。当然也可以安装其他的大模型，地址：<a href="https://ollama.com/library">https://ollama.com/library</a>)</p>
<p>安装完成其实就可以开始对话了。不过是在命令终端里，界面着实让人着急。<br><code>但是</code>可以安装可视化管理界面。</p>
<blockquote>
<p>建议性实践</p>
</blockquote>
<p>终端命令行执行</p>
<p>拉取docker镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure>

<p>等待下载完成之后进入docker可以看到一个镜像，点击启动<br><img src="https://img.funning.top/open-webui.png"></p>
<p>启动成功后在浏览器里输入：<a href="http://localhost:3000/">http://localhost:3000/</a><br>然后注册一下账号就能进入主页啦！<br><img src="https://img.funning.top/ui-1.png"></p>
<p>然后在这里可以<code>安装</code>大模型。（一切都可在这里操作）<br><img src="https://img.funning.top/ui-3.png"></p>
<p>可以自定义<code>知识库</code>，在这里上传就行啦<br><img src="https://img.funning.top/ui-2.png"></p>
<p>最后你就可以<code>无限次数</code>的畅想AI啦<br><img src="https://img.funning.top/ui-4.png"></p>
<p>我这里下载的是 llama2 一个7十亿训练的大模型。（各位根据自己的需求以及电脑配置来下载）<br>提问的时候也可以上传文件。</p>
<h1 id="链接地址："><a href="#链接地址：" class="headerlink" title="链接地址："></a>链接地址：</h1><ol>
<li>Gemma官网：<a href="https://ai.google.dev/gemma?hl=zh-cn">https://ai.google.dev/gemma?hl=zh-cn</a></li>
<li>ollama官网：<a href="https://ollama.com/download">https://ollama.com/download</a></li>
<li>ollama github：<a href="https://github.com/ollama/ollama">https://github.com/ollama/ollama</a></li>
<li>ChatGPT-ollama-UI：<a href="https://github.com/ivanfioravanti/chatbot-ollama">https://github.com/ivanfioravanti/chatbot-ollama</a></li>
<li>OpenAI-translator：<a href="https://github.com/openai-translator/openai-translator">https://github.com/openai-translator/openai-translator</a></li>
<li>Docker：<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></li>
<li>open-webui github：<a href="https://github.com/open-webui/open-webui">https://github.com/open-webui/open-webui</a></li>
</ol>
<h1 id="参考命令"><a href="#参考命令" class="headerlink" title="参考命令"></a>参考命令</h1><ul>
<li>启动ollama：ollama serve</li>
<li>查看ollama是否安装：ollama –version</li>
<li>安装gemma:2b版大模型的命令：ollama run gemma:2b</li>
<li>退出对话：ctrl+d</li>
<li>查看本地安装的模型：ollama list</li>
<li>删除某个模型：ollama rm 模型名称</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年免费域名注册网站大全(持续更新,建议收藏)</title>
    <url>/article/112230.html</url>
    <content><![CDATA[<h1 id="域名免费也能拥有，你的网络名片由你定义！"><a href="#域名免费也能拥有，你的网络名片由你定义！" class="headerlink" title="域名免费也能拥有，你的网络名片由你定义！"></a>域名免费也能拥有，你的网络名片由你定义！</h1><p>域名，如同互联网上的门牌号，是我们在数字世界中的身份象征。对于许多人来说，拥有一个属于自己的域名，是迈入网络世界的第一步。</p>
<p>然而，对于没有建站需求或只是临时使用域名的人来说，花钱购买域名似乎有些浪费。难道就没有免费的域名可供选择吗？</p>
<p>当然有！今天，就让我们一起探秘免费域名注册的奇妙世界，开启你的个性化网络之旅！</p>
<h2 id="2024-5-1-最新可注册😊"><a href="#2024-5-1-最新可注册😊" class="headerlink" title="2024-5-1 最新可注册😊"></a>2024-5-1 最新可注册😊</h2><blockquote>
<p>最新 <code>伊朗顶级域名</code></p>
</blockquote>
<p>本次域名是<code>顶级域名</code>, 强烈推荐 ！！！</p>
<p>本次域名提供了后缀为 <code> .ir</code> 免费域名。</p>
<p>关键是可以托管到 <code>cloudflare</code> ，实在是太香啦！</p>
<blockquote>
<p><a href="https://blog.funning.top/article/112250.html">查看详细教程</a></p>
</blockquote>
<p><img src="http://qnocs.funning.top/blog/ir-domain/Snipaste_2024-04-30_09-20-02.png" alt="伊朗永久免费域名"></p>
<h2 id="2024-4-25-最新可注册😊"><a href="#2024-4-25-最新可注册😊" class="headerlink" title="2024-4-25 最新可注册😊"></a>2024-4-25 最新可注册😊</h2><p><code>香港域名</code>，抓紧时间注册，先到先得，有三个后缀可选择。而且是<code>永久免费</code>。<br><img src="https://img.funning.top/hk-domain.png" alt="香港永久免费域名"></p>
<ul>
<li>.nets.hk</li>
<li>.orgs.hk</li>
<li>.coms.hk</li>
</ul>
<p><a href="http://www.coms.hk/hk/panel.php">点击注册</a></p>
<p><a href="https://blog.funning.top/article/112248.html">点击查看详细注册步骤</a></p>
<h2 id="目前可以申请"><a href="#目前可以申请" class="headerlink" title="目前可以申请"></a>目前可以申请</h2><blockquote>
<p><code>nom.za</code></p>
</blockquote>
<p>二级域名，永久免费，<code>可托管cf</code>，地址：<a href="https://secure.nom.za/">https://secure.nom.za/</a></p>
<blockquote>
<p><code>cloudns.eu.org</code></p>
</blockquote>
<p>二级域名，永久免费，现在注册后缀可能会变，<code>可托管cf</code>。</p>
<blockquote>
<p><code>cloudns.eu.biz</code></p>
</blockquote>
<p>二级域名，永久免费，现在注册后缀可能会变，<code>可托管cf</code>。</p>
<blockquote>
<p><code>cloudns.be</code></p>
</blockquote>
<p>二级域名，永久免费，不能托管cf，但功能跟cf差不多。</p>
<blockquote>
<p><code>cloudns.ch</code></p>
</blockquote>
<p>二级域名，永久免费，不能托管cf，但功能跟cf差不多。</p>
<h2 id="目前申请有一定的困难"><a href="#目前申请有一定的困难" class="headerlink" title="目前申请有一定的困难"></a>目前申请有一定的困难</h2><blockquote>
<p><code>eu.org</code></p>
</blockquote>
<p>二级域名，永久免费，申请困难，现在注册申请时间比以往还久，迟迟没结果，<code>可托管cf</code>。</p>
<h2 id="目前低价便宜申请"><a href="#目前低价便宜申请" class="headerlink" title="目前低价便宜申请"></a>目前低价便宜申请</h2><blockquote>
<p><code>uk</code></p>
</blockquote>
<p>顶级域名，首年免费，<code>可托管cf</code>。</p>
<blockquote>
<p><code>co.uk</code></p>
</blockquote>
<p>二级域名，首年免费，<code>可托管cf</code>。</p>
<blockquote>
<p><code>pp.ua</code></p>
</blockquote>
<p>二级域名，首年免费，续期1年0.2 ，10年2 rmb，<code>可托管cf</code>。</p>
<blockquote>
<p><code>free.hr</code></p>
</blockquote>
<p>二级域名，续期1年1.6 ，10年16 rmb，<code>可托管cf</code>。</p>
<blockquote>
<p><code>xyz</code></p>
</blockquote>
<p>数字域名，一年5元，十年50元，续费不变，<code>可托管cf</code>。</p>
<blockquote>
<p><code>free.tr</code></p>
</blockquote>
<p>便宜域名，一年1.5元，续费不涨价，国外厂商域名注册服务商：<a href="https://regtons.com/en/register">https://regtons.com/en/register</a>  <code>可托管cf</code>。</p>
<blockquote>
<p><code>publicvm.com</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>run.place</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>linkpc.net</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>line.pm</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>work.gd</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>dns.army</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>dns.navy</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>dynv6.net</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>v6.army</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>v6.navy</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>v6.rocks</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<blockquote>
<p><code>dd-dns.de</code></p>
</blockquote>
<p>子域名，<code>不能托管cf</code>，免费一年 。</p>
<h2 id="目前不能申请"><a href="#目前不能申请" class="headerlink" title="目前不能申请"></a>目前不能申请</h2><blockquote>
<p><code>tk</code></p>
</blockquote>
<p>顶级域名，对外宣称永久免费，实际现在免费10年,<code>可托管cf</code>。</p>
<blockquote>
<p><code>ml</code></p>
</blockquote>
<p>顶级域名，对外宣称永久免费，实际现在免费10年,<code>可托管cf</code>。</p>
<blockquote>
<p><code>ga</code></p>
</blockquote>
<p>顶级域名，对外宣称永久免费，实际现在免费10年,<code>可托管cf</code>。</p>
<blockquote>
<p><code>cf</code></p>
</blockquote>
<p>顶级域名，对外宣称永久免费，实际现在免费10年,<code>可托管cf</code>。</p>
<blockquote>
<p><code>gq</code></p>
</blockquote>
<p>顶级域名，对外宣称永久免费，实际现在免费10年,<code>可托管cf</code>。</p>
]]></content>
      <categories>
        <category>域名</category>
        <category>免费</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>🎁 香港域名免费注册礼包！抢先注册，抢先成功！</title>
    <url>/article/112248.html</url>
    <content><![CDATA[<h2 id="COMS-HK-免费域名自2014年为香港用户带来优质的免费域名服务，由3Domains进行管理及营运。"><a href="#COMS-HK-免费域名自2014年为香港用户带来优质的免费域名服务，由3Domains进行管理及营运。" class="headerlink" title="COMS.HK 免费域名自2014年为香港用户带来优质的免费域名服务，由3Domains进行管理及营运。"></a>COMS.HK 免费域名自2014年为香港用户带来优质的免费域名服务，由3Domains进行管理及营运。</h2><blockquote>
<p>如果注册不成功的，建议切换<code>香港节点</code></p>
</blockquote>
<p><img src="https://img2.funning.top/file/6bdeafe11ee1c99e09c6b.png"></p>
<p><a href="http://www.coms.hk/cn/">点击进入</a></p>
<p><img src="https://img2.funning.top/file/f3ca0bdbb5d34c2c8d30b.png"></p>
<blockquote>
<p>点这里的小卡片，把个人信息输入好。</p>
</blockquote>
<p><img src="https://img2.funning.top/file/42c56d1217f7ed4dbba84.png"></p>
<blockquote>
<p>⚠️两个地方：手机号的区号和电邮地址，也就是注册时用的邮箱</p>
</blockquote>
<p><img src="https://img2.funning.top/file/ccf9634b4510d3eb9709b.png"></p>
<blockquote>
<p>注册好后，可以设置A记录、cname等记录，还可以重定向，非常实用</p>
</blockquote>
<p><img src="https://img2.funning.top/file/f976cf5ee96ab91f52d05.png"></p>
<p><img src="https://img2.funning.top/file/21beec7276fab538cd879.png"></p>
]]></content>
      <categories>
        <category>域名</category>
        <category>免费</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable接口你真的了解吗？</title>
    <url>/article/112219.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回<br>Java 对象原有的状态。</p>
<p>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；</p>
<p>序列化有一条规则，就是要序列化的对象必须实现 <code>Serializbale</code> 接口，否则就会报 NotSerializableException 异常。</p>
<p>好，来看看 <code>Serializbale</code> 接口的定义吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就一个空的接口嘛，竟然能够保证实现了它的“类对象”被序列化和反序列化？</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在回答上述问题之前，我们先来创建一个类（只有两个字段，和对应的 <code>getter/setter</code>），用于序列化和反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，由于 <code>Obj</code> 没有实现 <code>Serializbale</code> 接口，所以在运行测试类的时候会抛出异常，堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.NotSerializableException: com.cmower.java_demo.xuliehua.Obj</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">	at com.cmower.java_demo.xuliehua.Test.main(Test.java:21)</span><br></pre></td></tr></table></figure>

<p>顺着堆栈信息，我们来看一下 <code>ObjectOutputStream</code> 的 <code>writeObject0()</code> 方法。其部分源码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化</span><br><span class="line">if(obj instanceof String)&#123;</span><br><span class="line"></span><br><span class="line">writeString((String) obj,unshared);</span><br><span class="line">        &#125;</span><br><span class="line">// 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化</span><br><span class="line">        else if(cl.</span><br><span class="line"></span><br><span class="line">isArray())&#123;</span><br><span class="line"></span><br><span class="line">writeArray(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化</span><br><span class="line">        else if(obj instanceof Enum)&#123;</span><br><span class="line"></span><br><span class="line">writeEnum((Enum&lt;?&gt;) obj,desc,unshared);</span><br><span class="line">        &#125;</span><br><span class="line">// 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化</span><br><span class="line">        else if(obj instanceof Serializable)&#123;</span><br><span class="line"></span><br><span class="line">writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 如果对象不能被序列化，则抛出 NotSerializableException 异常</span><br><span class="line">        else&#123;</span><br><span class="line">        if(extendedDebugInfo)&#123;</span><br><span class="line">        throw new</span><br><span class="line"></span><br><span class="line">NotSerializableException(</span><br><span class="line">        cl.getName() +&quot;\n&quot;+debugInfoStack.</span><br><span class="line"></span><br><span class="line">toString());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        throw new</span><br><span class="line"></span><br><span class="line">NotSerializableException(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>ObjectOutputStream</code> 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 <code>Serializable</code><br>，如果全都不是的话，抛出 <code>NotSerializableException</code>。</p>
<p>假如 <code>Obj</code> 实现了 <code>Serializable</code> 接口，就可以序列化和反序列化了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体怎么序列化呢？</p>
<p>以 <code>ObjectOutputStream</code><br>为例吧，它在序列化的时候会依次调用 <code>writeObject()</code>→<code>writeObject0()</code>→<code>writeOrdinaryObject()</code>→<code>writeSerialData()</code>→<code>invokeWriteObject()</code>→<code>defaultWriteFields()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对象的类，并检查是否可以进行默认的序列化</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象的基本类型字段的数量，以及这些字段的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// 将基本类型字段的值写入输出流</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象的非基本类型字段的值</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="comment">// 循环写入对象的非基本类型字段的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 调用 writeObject0 方法将对象的非基本类型字段序列化写入输出流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在写入过程中出现异常，则将异常包装成 IOException 抛出</span></span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abortIOException == <span class="literal">null</span>) &#123;</span><br><span class="line">                abortIOException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那怎么反序列化呢？</p>
<p>以 <code>ObjectInputStream</code><br>为例，它在反序列化的时候会依次调用 <code>readObject()</code>→<code>readObject0()</code>→<code>readOrdinaryObject()</code>→<code>readSerialData()</code>→<code>defaultReadFields()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultReadFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对象的类，并检查对象是否属于该类</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象的基本类型字段的数量和值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="literal">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="title class_">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从输入流中读取基本类型字段的值，并存储在 primVals 数组中</span></span><br><span class="line">    bin.readFully(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 primVals 数组中的基本类型字段的值设置到对象的相应字段中</span></span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象的非基本类型字段的数量和值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">objHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    <span class="comment">// 循环读取对象的非基本类型字段的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 调用 readObject0 方法读取对象的非基本类型字段的值</span></span><br><span class="line">        <span class="type">ObjectStreamField</span> <span class="variable">f</span> <span class="operator">=</span> fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(Object.class, f.isUnshared());</span><br><span class="line">        <span class="comment">// 如果该字段是一个引用字段，则将其标记为依赖该对象</span></span><br><span class="line">        <span class="keyword">if</span> (f.getField() != <span class="literal">null</span>) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 objVals 数组中的非基本类型字段的值设置到对象的相应字段中</span></span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Serializable</code>接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>开门见山的说吧，<code>static</code>和 <code>transient</code>修饰的字段是不会被序列化的。</p>
<p>为什么呢？我们先来证明，再来解释原因。</p>
<p>首先，在 <code>Obj</code> 类中增加两个字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="string">&quot;哈哈&quot;</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">String</span> <span class="variable">meizi</span> <span class="operator">=</span> <span class="string">&quot;小米&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Obj&#123;&quot;</span> + <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age + <span class="string">&quot;,pre=&quot;</span> + pre + <span class="string">&quot;,meizi=&quot;</span> + meizi + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在测试类中打印序列化前和反序列化后的对象，并在序列化后和反序列化前改变 <code>static</code> 字段的值。具体代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Obj Obj = new Obj();</span><br><span class="line">Obj.</span><br><span class="line"></span><br><span class="line">setName(&quot;小米&quot;);</span><br><span class="line">Obj.</span><br><span class="line"></span><br><span class="line">setAge(18);</span><br><span class="line">System.out.</span><br><span class="line"></span><br><span class="line">println(Obj);</span><br><span class="line"></span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try(</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">        oos.</span><br><span class="line"></span><br><span class="line">writeObject(Obj);</span><br><span class="line">    &#125;catch(</span><br><span class="line">IOException e)&#123;</span><br><span class="line">        e.</span><br><span class="line"></span><br><span class="line">printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 改变 static 字段的值</span><br><span class="line">Obj.pre =&quot;不火锅&quot;;</span><br><span class="line"></span><br><span class="line">// 从文件中读出对象</span><br><span class="line">        try(</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">Obj Obj1 = (Obj) ois.readObject();</span><br><span class="line">    System.out.</span><br><span class="line"></span><br><span class="line">println(Obj1);</span><br><span class="line">&#125;catch(IOException |</span><br><span class="line">ClassNotFoundException e)&#123;</span><br><span class="line">        e.</span><br><span class="line"></span><br><span class="line">printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Obj&#123;name=小米,age=18,pre=火锅,meizi=小米&#125;</span><br><span class="line">Obj&#123;name=小米,age=18,pre=不火锅,meizi=null&#125;</span><br></pre></td></tr></table></figure>

<p>从结果的对比当中，我们可以发现：</p>
<p>1）序列化前，<code>pre</code> 的值为“火锅”，序列化后，<code>pre</code> 的值修改为“不火锅”，反序列化后，<code>pre</code> 的值为“不火锅”，而不是序列化前的状态“火锅”。</p>
<p>为什么呢？因为序列化保存的是对象的状态，而 <code>static</code> 修饰的字段属于类的状态，因此可以证明序列化并不保存 <code>static</code> 修饰的字段。</p>
<p>2）序列化前，<code>meizi</code> 的值为“小米”，反序列化后，<code>meizi</code> 的值为 <code>null</code>，而不是序列化前的状态“小米”。</p>
<p>为什么呢？<code>transient</code> 的中文字义为“临时的”（论英语的重要性），它可以阻止字段被序列化到文件中，在被反序列化后，<code>transient</code><br>字段的值被设为初始值，比如 <code>int</code> 型的初始值为 0，对象型的初始值为 <code>null</code>。</p>
<p>如果想要深究源码的话，你可以在 <code>ObjectStreamClass</code> 中发现下面这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</span><br><span class="line">    <span class="comment">// 获取该类中声明的所有字段</span></span><br><span class="line">    Field[] clFields = cl.getDeclaredFields();</span><br><span class="line">    ArrayList&lt;ObjectStreamField&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> Modifier.STATIC | Modifier.TRANSIENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有字段，将非 static 和 transient 的字段添加到 list 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clFields.length; i++) &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clFields[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mods</span> <span class="operator">=</span> field.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> ((mods &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名、字段类型和字段是否可序列化创建一个 ObjectStreamField 对象</span></span><br><span class="line">            <span class="type">ObjectStreamField</span> <span class="variable">osf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(field.getName(), field.getType(), !Serializable.class.isAssignableFrom(cl));</span><br><span class="line">            list.add(osf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="comment">// 如果 list 为空，则返回一个空的 ObjectStreamField 数组，否则将 list 转换为 ObjectStreamField 数组并返回</span></span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? NO_FIELDS :</span><br><span class="line">            list.toArray(<span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>[size]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到 <code>Modifier.STATIC | Modifier.TRANSIENT</code> 了吧，这两个修饰符标记的字段就没有被放入到序列化的字段中，明白了吧？</p>
<h3 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h3><p>除了 <code>Serializable</code> 之外，Java 还提供了一个序列化接口 <code>Externalizable</code>（念起来有点拗口）。</p>
<p>两个接口有什么不一样的吗？试一试就知道了。</p>
<p>首先，把 <code>Obj</code> 类实现的接口  <code>Serializable</code> 替换为 <code>Externalizable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Obj</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Obj&#123;&quot;</span> + <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 <code>Externalizable</code> 接口的 <code>Obj</code> 类和实现 <code>Serializable</code> 接口的 <code>Obj</code> 类有一些不同：</p>
<p>1）新增了一个无参的构造方法。</p>
<p>使用 <code>Externalizable</code> 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException: com.cmower.java_demo.xuliehua1.Obj; no valid constructor</span><br><span class="line">	at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:150)</span><br><span class="line">	at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:790)</span><br><span class="line">	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1782)</span><br><span class="line">	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)</span><br><span class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)</span><br><span class="line">	at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>

<p>2）新增了两个方法 <code>writeExternal()</code> 和 <code>readExternal()</code>，实现 <code>Externalizable</code> 接口所必须的。</p>
<p>然后，我们再在测试类中打印序列化前和反序列化后的对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Obj Obj = new Obj();</span><br><span class="line">Obj.</span><br><span class="line"></span><br><span class="line">setName(&quot;小米&quot;);</span><br><span class="line">Obj.</span><br><span class="line"></span><br><span class="line">setAge(18);</span><br><span class="line">System.out.</span><br><span class="line"></span><br><span class="line">println(Obj);</span><br><span class="line"></span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try(</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">        oos.</span><br><span class="line"></span><br><span class="line">writeObject(Obj);</span><br><span class="line">&#125;catch(</span><br><span class="line">IOException e)&#123;</span><br><span class="line">        e.</span><br><span class="line"></span><br><span class="line">printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从文件中读出对象</span><br><span class="line">        try(</span><br><span class="line">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">Obj Obj1 = (Obj) ois.readObject();</span><br><span class="line">	System.out.</span><br><span class="line"></span><br><span class="line">println(Obj1);</span><br><span class="line">&#125;catch(IOException |</span><br><span class="line">ClassNotFoundException e)&#123;</span><br><span class="line">        e.</span><br><span class="line"></span><br><span class="line">printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// Obj&#123;name=小米,age=18&#125;</span><br><span class="line">// Obj&#123;name=null,age=0&#125;</span><br></pre></td></tr></table></figure>

<p>从输出的结果看，反序列化后得到的对象字段都变成了默认值，也就是说，序列化之前的对象状态没有被“冻结”下来。</p>
<p>为什么呢？因为我们没有为 <code>Obj</code> 类重写具体的 <code>writeExternal()</code> 和 <code>readExternal()</code> 方法。那该怎么重写呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> &#123;</span><br><span class="line">    out.writeObject(name);</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> &#123;</span><br><span class="line">    name = (String) in.readObject();</span><br><span class="line">    age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）调用 <code>ObjectOutput</code> 的 <code>writeObject()</code> 方法将字符串类型的 <code>name</code> 写入到输出流中；</p>
<p>2）调用 <code>ObjectOutput</code> 的 <code>writeInt()</code> 方法将整型的 <code>age</code> 写入到输出流中；</p>
<p>3）调用 <code>ObjectInput</code> 的 <code>readObject()</code> 方法将字符串类型的 <code>name</code> 读入到输入流中；</p>
<p>4）调用 <code>ObjectInput</code> 的 <code>readInt()</code> 方法将字符串类型的 <code>age</code> 读入到输入流中；</p>
<p>再运行一次测试了类，你会发现对象可以正常地序列化和反序列化了。</p>
<blockquote>
<p>序列化前：Obj{name&#x3D;小米,age&#x3D;18}<br>序列化后：Obj{name&#x3D;小米,age&#x3D;18}</p>
</blockquote>
<p>总结一下：</p>
<p>Externalizable 和 Serializable 都是用于实现 Java 对象的序列化和反序列化的接口，但是它们有以下区别：</p>
<p>①、Serializable 是 Java 标准库提供的接口，而 Externalizable 是 Serializable 的子接口;</p>
<p>②、Serializable 接口不需要实现任何方法，只需要将需要序列化的类标记为 Serializable 即可，而 Externalizable 接口需要实现<br>writeExternal 和 readExternal 两个方法；</p>
<p>③、Externalizable 接口提供了更高的序列化控制能力，可以在序列化和反序列化过程中对对象进行自定义的处理，如对一些敏感信息进行加密和解密。</p>
<h3 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h3><p>你知道 <code> private static final long serialVersionUID = -2095916884810199532L;</code> 这段代码的作用吗？</p>
<p><code>serialVersionUID</code> 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java<br>虚拟机会把字节流中的 <code>serialVersionUID</code> 与被序列化类中的 <code>serialVersionUID</code> 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。</p>
<p>当一个类实现了 <code>Serializable</code> 接口后，IDE 就会提醒该类最好产生一个序列化 ID，就像下面这样：</p>
<p>1）添加一个默认版本的序列化 ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>2）添加一个随机生成的不重复的序列化 ID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2095916884810199532L</span>;</span><br></pre></td></tr></table></figure>

<p>3）添加 <code>@SuppressWarnings</code> 注解。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;);</span><br></pre></td></tr></table></figure>

<p>怎么选择呢？</p>
<p>首先，我们采用第二种办法，在被序列化类中添加一个随机生成的序列化 ID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2095916884810199532L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，序列化一个 <code>Obj</code> 对象到文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Obj Obj = new Obj();</span><br><span class="line">Obj.setName(&quot;小米&quot;);</span><br><span class="line">Obj.setAge(18);</span><br><span class="line">System.out.println(Obj);</span><br><span class="line"></span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));) &#123;</span><br><span class="line">	oos.writeObject(Obj);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，我们悄悄地把 <code>Obj</code> 类的序列化 ID 偷梁换柱一下，嘿嘿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// private static final long serialVersionUID = -2095916884810199532L;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2095916884810199533L</span>;</span><br></pre></td></tr></table></figure>

<p>好了，准备反序列化吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">Obj Obj = (Obj) ois.readObject();</span><br><span class="line">	System.out.</span><br><span class="line"></span><br><span class="line">println(Obj);</span><br><span class="line">&#125;catch(IOException |</span><br><span class="line">ClassNotFoundException e)&#123;</span><br><span class="line">        e.</span><br><span class="line"></span><br><span class="line">printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哎呀，出错了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532,</span><br><span class="line">local class serialVersionUID = -2095916884810199533</span><br><span class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">	at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>

<p>异常堆栈信息里面告诉我们，从持久化文件里面读取到的序列化 ID 和本地的序列化 ID 不一致，无法反序列化。</p>
<p>那假如我们采用第三种方法，为 <code>Obj</code> 类添加个 <code>@SuppressWarnings(&quot;serial&quot;)</code> 注解呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，再来一次反序列化吧。可惜依然报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532, </span><br><span class="line">local class serialVersionUID = -3818877437117647968</span><br><span class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">	at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>

<p>异常堆栈信息里面告诉我们，本地的序列化 ID 为 -3818877437117647968，和持久化文件里面读取到的序列化 ID<br>仍然不一致，无法反序列化。这说明什么呢？使用 <code>@SuppressWarnings(&quot;serial&quot;)</code> 注解时，该注解会为被序列化类自动生成一个随机的序列化<br>ID。</p>
<p>由此可以证明，**Java 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的因素就是序列化 ID 是否一致<br>**。</p>
<p>也就是说，如果没有特殊需求，采用默认的序列化 ID（1L）就可以，这样可以确保代码一致时反序列化成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title>java8 新特性总结</title>
    <url>/article/112225.html</url>
    <content><![CDATA[<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p>
<ol>
<li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li>
<li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li>
</ol>
<p>我们来看一个实际的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceNew1 default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceNewImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceNew</span> , InterfaceNew1&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceNewImpl</span> <span class="variable">interfaceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceNewImpl</span>();</span><br><span class="line">        interfaceNew.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        InterfaceNew1.<span class="built_in">super</span>.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p>
<p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p>
<p>其实它们还是有区别的</p>
<ol>
<li>interface 和 class 的区别，好像是废话，主要有：</li>
</ol>
<ul>
<li>接口多实现，类单继承</li>
<li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li>
</ul>
<ol start="2">
<li>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</li>
</ol>
<p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p>
<h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p>
<p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p>
<p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有</p>
<p><code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p>
<p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p>
<blockquote>
<p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p>
</blockquote>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression 或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-实战"><a href="#Lambda-实战" class="headerlink" title="Lambda 实战"></a>Lambda 实战</h3><p>我们用常用的实例来感受 Lambda 带来的便利</p>
<h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p>
<p><strong>1.<code>Runnable</code> 接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;The runable now is using!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">//用lambda</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;It&#x27;s a lambda function!&quot;)).start();</span><br></pre></td></tr></table></figure>

<p><strong>2.<code>Comparator</code> 接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(1, 2, 3);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">    return o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//Lambda</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line">//分解开</span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br></pre></td></tr></table></figure>

<p><strong>3.<code>Listener</code> 接口</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JButton button = new JButton();</span><br><span class="line">button.addItemListener(new ItemListener() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void itemStateChanged(ItemEvent e) &#123;</span><br><span class="line">   e.getItem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//lambda</span><br><span class="line">button.addItemListener(e -&gt; e.getItem());</span><br></pre></td></tr></table></figure>

<p><strong>4.自定义接口</strong></p>
<p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Comparator&lt;T&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们自定义一个函数式接口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface LambdaInterface &#123;</span><br><span class="line"> void f();</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">public class LambdaClass &#123;</span><br><span class="line">    public static void forEg() &#123;</span><br><span class="line">        lambdaInterfaceDemo(()-&gt; System.out.println(&quot;自定义函数式接口&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //函数式接口参数</span><br><span class="line">    static void lambdaInterfaceDemo(LambdaInterface i)&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">void lamndaFor() &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br><span class="line">        //传统foreach</span><br><span class="line">        for (String s : strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        //Lambda foreach</span><br><span class="line">        strings.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">        //or</span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">     //map</span><br><span class="line">        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;System.out.println(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line">//i =3;</span><br></pre></td></tr></table></figure>

<p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p>
<p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p>
<p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p>
<h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol>
<li>stream 串行流</li>
<li>parallelStream 并行流，可多线程执行</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 返回一个串行流</span><br><span class="line">*/</span><br><span class="line">default Stream&lt;E&gt; stream()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回一个并行流</span><br><span class="line">*/</span><br><span class="line">default Stream&lt;E&gt; parallelStream()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回T的流</span><br><span class="line">*/</span><br><span class="line">public static&lt;T&gt; Stream&lt;T&gt; of(T t)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回其元素是指定值的顺序流。</span><br><span class="line">*/</span><br><span class="line">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;</span><br><span class="line">    return Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span><br><span class="line">*/</span><br><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 此流的所有元素是否与提供的predicate匹配。</span><br><span class="line">*/</span><br><span class="line">boolean allMatch(Predicate&lt;? super T&gt; predicate)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 此流任意元素是否有与提供的predicate匹配。</span><br><span class="line">*/</span><br><span class="line">boolean anyMatch(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回一个 Stream的构建器。</span><br><span class="line">*/</span><br><span class="line">public static&lt;T&gt; Builder&lt;T&gt; builder();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 使用 Collector对此流的元素进行归纳</span><br><span class="line">*/</span><br><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回此流中的元素数。</span><br><span class="line">*/</span><br><span class="line">long count();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span><br><span class="line">*/</span><br><span class="line">Stream&lt;T&gt; distinct();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 遍历</span><br><span class="line">*/</span><br><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span><br><span class="line">*/</span><br><span class="line">Stream&lt;T&gt; limit(long maxSize);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 用于映射每个元素到对应的结果</span><br><span class="line">*/</span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 根据提供的 Comparator进行排序。</span><br><span class="line">*/</span><br><span class="line">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span><br><span class="line">*/</span><br><span class="line">Stream&lt;T&gt; skip(long n);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 返回一个包含此流的元素的数组。</span><br><span class="line">*/</span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span><br><span class="line">*/</span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 合并流</span><br><span class="line">*/</span><br><span class="line">public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></pre></td></tr></table></figure>

<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p>
<p>我们下面分解一下 <code>filter</code> 方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void laziness()&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;def&quot;, &quot;gkh&quot;, &quot;abc&quot;);</span><br><span class="line">  Stream&lt;Integer&gt; stream = strings.stream().filter(new Predicate() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public boolean test(Object o) &#123;</span><br><span class="line">        System.out.println(&quot;Predicate.test 执行&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   System.out.println(&quot;count 执行&quot;);</span><br><span class="line">   stream.count();</span><br><span class="line">&#125;</span><br><span class="line">/*-------执行结果--------*/</span><br><span class="line">count 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br></pre></td></tr></table></figure>

<p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p>
<p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void parallelStreamTest()&#123;</span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 5, 4);</span><br><span class="line">   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+num));</span><br><span class="line">&#125;</span><br><span class="line">//执行结果</span><br><span class="line"><span class="meta prompt_">main&gt;</span><span class="language-bash">&gt;5</span></span><br><span class="line">ForkJoinPool.commonPool-worker-2&gt;&gt;4</span><br><span class="line">ForkJoinPool.commonPool-worker-11&gt;&gt;1</span><br><span class="line">ForkJoinPool.commonPool-worker-9&gt;&gt;2</span><br></pre></td></tr></table></figure>

<p>从结果中我们看到，for-each 用到的是多线程。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从源码和实例中我们可以总结出一些 stream 的特点</p>
<ol>
<li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li>
<li>方法参数都是函数式接口类型</li>
<li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li>
<li>Stream 不保存数据，不改变数据源</li>
</ol>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p>
<p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传统解决 NPE 的办法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Zoo zoo = getZoo();</span><br><span class="line">if(zoo != null)&#123;</span><br><span class="line">   Dog dog = zoo.getDog();</span><br><span class="line">   if(dog != null)&#123;</span><br><span class="line">      int age = dog.getAge();</span><br><span class="line">      System.out.println(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p>
<p><code>Optional</code> 是这样的实现的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>是不是简洁了很多呢？</p>
<h3 id="如何创建一个-Optional"><a href="#如何创建一个-Optional" class="headerlink" title="如何创建一个 Optional"></a>如何创建一个 Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Common instance for &#123;<span class="doctag">@code</span> empty()&#125;. 全局EMPTY对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value是null就返回EMPTY，否则就返回of(T)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 EMPTY 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Optional对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私有构造方法，给value赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p>
<p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p>
<p><code>map</code> 和 <code>flatMap</code> 都是将一个函数应用于集合中的每个元素，但不同的是<code>map</code>返回一个新的集合，<code>flatMap</code>是将每个元素都映射为一个集合，最后再将这个集合展平。</p>
<p>在实际应用场景中，如果<code>map</code>返回的是数组，那么最后得到的是一个二维数组，使用<code>flatMap</code>就是为了将这个二维数组展平变成一个一维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapAndFlatMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String[]&gt; listOfArrays = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;melon&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String[]&gt; mapResult = listOfArrays.stream()</span><br><span class="line">                .map(array -&gt; Arrays.stream(array).map(String::toUpperCase).toArray(String[]::<span class="keyword">new</span>))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using map:&quot;</span>);</span><br><span class="line">        System.out.println(mapResult);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; flatMapResult = listOfArrays.stream()</span><br><span class="line">                .flatMap(array -&gt; Arrays.stream(array).map(String::toUpperCase))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using flatMap:&quot;</span>);</span><br><span class="line">        System.out.println(flatMapResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using map:</span><br><span class="line">[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]</span><br><span class="line"></span><br><span class="line">Using flatMap:</span><br><span class="line">[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]</span><br></pre></td></tr></table></figure>

<p>最简单的理解就是<code>flatMap()</code>可以将<code>map()</code>的结果展开。</p>
<p>在<code>Optional</code>里面，当使用<code>map()</code>时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的<code>Optional</code>中。而使用<code>flatMap</code>时，如果映射函数返回的是一个<code>Optional</code>，它会将这个返回的<code>Optional</code>展平，不再包装成嵌套的<code>Optional</code>。</p>
<p>下面是一个对比的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用flatMap的代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cityUsingFlatMap</span> <span class="operator">=</span> getUserById(userId)</span><br><span class="line">                .flatMap(OptionalExample::getAddressByUser)</span><br><span class="line">                .map(Address::getCity)</span><br><span class="line">                .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city using flatMap: &quot;</span> + cityUsingFlatMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用flatMap的代码</span></span><br><span class="line">        Optional&lt;Optional&lt;Address&gt;&gt; optionalAddress = getUserById(userId)</span><br><span class="line">                .map(OptionalExample::getAddressByUser);</span><br><span class="line"></span><br><span class="line">        String cityWithoutFlatMap;</span><br><span class="line">        <span class="keyword">if</span> (optionalAddress.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Address&gt; addressOptional = optionalAddress.get();</span><br><span class="line">            <span class="keyword">if</span> (addressOptional.isPresent()) &#123;</span><br><span class="line">                <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> addressOptional.get();</span><br><span class="line">                cityWithoutFlatMap = address.getCity();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city without flatMap: &quot;</span> + cityWithoutFlatMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Stream</code>和<code>Optional</code>中正确使用<code>flatMap</code>可以减少很多不必要的代码。</p>
<h3 id="判断-value-是否为-null"><a href="#判断-value-是否为-null" class="headerlink" title="判断 value 是否为 null"></a>判断 value 是否为 null</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value是否为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value不为null执行consumer.accept</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">    consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-value"><a href="#获取-value" class="headerlink" title="获取 value"></a>获取 value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">* the result of that invocation.</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回other的执行结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回T</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则抛出参数返回的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value为null抛出NoSuchElementException，不为空返回value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是empty返回empty</span></span><br><span class="line"><span class="comment">* 2. predicate.test(value)==true 返回this，否则返回empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of()</code>、 <code>get()</code>、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).filter(v-&gt;v==1).orElse(3);</span><br></pre></td></tr></table></figure>

<h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p>
<ol>
<li>非线程安全</li>
<li>时区处理麻烦</li>
<li>各种格式化、和时间计算繁琐</li>
<li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li>
</ol>
<p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p>
<h3 id="java-time-主要类"><a href="#java-time-主要类" class="headerlink" title="java.time 主要类"></a>java.time 主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而 <code>java.time</code> 把它们进行了分离</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span><br><span class="line">LocalDate.class //日期 format: yyyy-MM-dd</span><br><span class="line">LocalTime.class //时间 format: HH:mm:ss</span><br></pre></td></tr></table></figure>

<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已弃用</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(2021, 1, 26);</span><br><span class="line">LocalDate.parse(&quot;2021-01-26&quot;);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22);</span><br><span class="line">LocalDateTime.parse(&quot;2021-01-26 12:12:22&quot;);</span><br><span class="line"></span><br><span class="line">LocalTime time = LocalTime.of(12, 12, 22);</span><br><span class="line">LocalTime.parse(&quot;12:12:22&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的 <code>of</code> 或 <code>parse</code> 方法。</p>
<h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1&#x2F;2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p>
<p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterDay</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">formatDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">     ca.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> ca.getTime();</span><br><span class="line">     <span class="type">String</span> <span class="variable">after</span> <span class="operator">=</span> formatDate.format(d);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">dates1</span> <span class="operator">=</span> <span class="string">&quot;2021-12-23&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">dates2</span> <span class="operator">=</span> <span class="string">&quot;2021-02-26&quot;</span>;</span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> format.parse(dates1);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> format.parse(dates2);</span><br><span class="line">     <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> (<span class="type">int</span>) ((date1.getTime() - date2.getTime()) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>));</span><br><span class="line">     System.out.println(dates1 + <span class="string">&quot;和&quot;</span> + dates2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushWeek</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">     <span class="comment">//方法1</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after</span> <span class="operator">=</span> localDate.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">     <span class="comment">//方法2</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after2</span> <span class="operator">=</span> localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-02-26&quot;</span>);</span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-23&quot;</span>);</span><br><span class="line">     <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(date1, date2);</span><br><span class="line">     System.out.println(<span class="string">&quot;date1 到 date2 相隔：&quot;</span></span><br><span class="line">                + period.getYears() + <span class="string">&quot;年&quot;</span></span><br><span class="line">                + period.getMonths() + <span class="string">&quot;月&quot;</span></span><br><span class="line">                + period.getDays() + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">   <span class="comment">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span></span><br><span class="line">     <span class="comment">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span></span><br><span class="line">     <span class="comment">//如果要获取纯粹的总天数应该用下面的方法</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> date2.toEpochDay() - date1.toEpochDay();</span><br><span class="line">     System.out.println(date1 + <span class="string">&quot;和&quot;</span> + date2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//打印结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h3><p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p>
<p><strong>Java 8 之前:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前月第一天：</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> format.format(c.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;first day:&quot;</span> + first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前月最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> format.format(ca.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">currCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.clear();</span><br><span class="line">        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));</span><br><span class="line">        calendar.roll(Calendar.DAY_OF_YEAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 8 之后:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastMondayOf2021</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p>
<h3 id="JDBC-和-java8"><a href="#JDBC-和-java8" class="headerlink" title="JDBC 和 java8"></a>JDBC 和 java8</h3><p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p>
<ol>
<li><code>Date</code> —&gt; <code>LocalDate</code></li>
<li><code>Time</code> —&gt; <code>LocalTime</code></li>
<li><code>Timestamp</code> —&gt; <code>LocalDateTime</code></li>
</ol>
<p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><blockquote>
<p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p>
</blockquote>
<p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//北京时间：Wed Jan 27 14:05:29 CST 2021</span><br><span class="line">Date date = new Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat bjSdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">//北京时区</span><br><span class="line">bjSdf.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));</span><br><span class="line">System.out.println(&quot;毫秒数:&quot; + date.getTime() + &quot;, 北京时间:&quot; + bjSdf.format(date));</span><br><span class="line"></span><br><span class="line">//东京时区</span><br><span class="line">SimpleDateFormat tokyoSdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">tokyoSdf.setTimeZone(TimeZone.getTimeZone(&quot;Asia/Tokyo&quot;));  // 设置东京时区</span><br><span class="line">System.out.println(&quot;毫秒数:&quot; + date.getTime() + &quot;, 东京时间:&quot; + tokyoSdf.format(date));</span><br><span class="line"></span><br><span class="line">//如果直接print会自动转成当前时区的时间</span><br><span class="line">System.out.println(date);</span><br><span class="line">//Wed Jan 27 14:05:29 CST 2021</span><br></pre></td></tr></table></figure>

<p>在新特性中引入了 <code>java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//当前时区时间</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(&quot;当前时区时间: &quot; + zonedDateTime);</span><br><span class="line"></span><br><span class="line">//东京时间</span><br><span class="line">ZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(&quot;JST&quot;));</span><br><span class="line">ZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId);</span><br><span class="line">System.out.println(&quot;东京时间: &quot; + tokyoTime);</span><br><span class="line"></span><br><span class="line">// ZonedDateTime 转 LocalDateTime</span><br><span class="line">LocalDateTime localDateTime = tokyoTime.toLocalDateTime();</span><br><span class="line">System.out.println(&quot;东京时间转当地时间: &quot; + localDateTime);</span><br><span class="line"></span><br><span class="line">//LocalDateTime 转 ZonedDateTime</span><br><span class="line">ZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(&quot;本地时区时间: &quot; + localZoned);</span><br><span class="line"></span><br><span class="line">//打印结果</span><br><span class="line">当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai]</span><br><span class="line">东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo]</span><br><span class="line">东京时间转当地时间: 2021-01-27T15:43:58.735</span><br><span class="line">当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们梳理总结的 java 8 新特性有</p>
<ul>
<li>Interface &amp; functional Interface</li>
<li>Lambda</li>
<li>Stream</li>
<li>Optional</li>
<li>Date time-api</li>
</ul>
]]></content>
      <categories>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Add chat history 添加聊天记录</title>
    <url>/article/112244.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在许多问答应用程序中，我们希望允许用户进行来回的对话，这意味着应用程序需要对过去的问题和答案进行某种“记忆”，并将这些问题和答案纳入当前思维中。</p>
<blockquote>
<p>需要做到两件事：</p>
</blockquote>
<ul>
<li><p>提示：更新我们的提示，以支持历史消息作为输入。</p>
</li>
<li><p>情境化问题：添加一个子链，它接受最新的用户问题，并在聊天历史的上下文中重新表达。这是需要的，以防最新的问题引用了过去消息中的某些上下文。<br>例如，如果用户问一个后续问题，如“你能详细说明第二点吗？”<br>，如果没有先前消息的上下文，这是无法理解的。因此，我们不能有效地执行检索这样的问题。</p>
</li>
</ul>
<h1 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h1><h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BeautifulSoup (通常缩写为：BS4)  用于解析 HTML 和 XML 文件。它提供了从 HTML 和 XML 文档中提取数据的功能，以及对解析树进行导航的工具。</span></span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> hub</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> WebBaseLoader</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough</span><br><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br></pre></td></tr></table></figure>

<h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;your key&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_BASE&quot;</span>] = <span class="string">&#x27;https://api.moonshot.cn/v1/&#x27;</span></span><br><span class="line"></span><br><span class="line">api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">base_url = os.getenv(<span class="string">&quot;OPENAI_API_BASE&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;api_key=&quot;</span> + api_key, <span class="string">&quot;base_url=&quot;</span> + base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型(两种方式)：</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chat = ChatOpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">).bind(logprobs=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="embeddings-初始化"><a href="#embeddings-初始化" class="headerlink" title="embeddings 初始化"></a>embeddings 初始化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> SentenceTransformerEmbeddings</span><br><span class="line"></span><br><span class="line">embeddings = SentenceTransformerEmbeddings(model_name=<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Chain-without-chat-history-无聊天记录的链"><a href="#Chain-without-chat-history-无聊天记录的链" class="headerlink" title="Chain without chat history 无聊天记录的链"></a>Chain without chat history 无聊天记录的链</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无聊天记录的链</span></span><br><span class="line"><span class="comment"># Load, chunk and index the contents of the blog.</span></span><br><span class="line">loader = WebBaseLoader(</span><br><span class="line">    web_paths=(<span class="string">&quot;https://lilianweng.github.io/posts/2023-06-23-agent/&quot;</span>,),</span><br><span class="line">    bs_kwargs=<span class="built_in">dict</span>(</span><br><span class="line">        parse_only=bs4.SoupStrainer(</span><br><span class="line">            class_=(<span class="string">&quot;post-content&quot;</span>, <span class="string">&quot;post-title&quot;</span>, <span class="string">&quot;post-header&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">docs = loader.load()</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">200</span>)</span><br><span class="line">splits = text_splitter.split_documents(docs)</span><br><span class="line">vectorstore = Chroma.from_documents(documents=splits, embedding=embeddings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve and generate using the relevant snippets of the blog.</span></span><br><span class="line">retriever = vectorstore.as_retriever()</span><br><span class="line">prompt = hub.pull(<span class="string">&quot;rlm/rag-prompt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_docs</span>(<span class="params">docs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n\n&quot;</span>.join(doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> docs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rag_chain = (</span><br><span class="line">        &#123;<span class="string">&quot;context&quot;</span>: retriever | format_docs, <span class="string">&quot;question&quot;</span>: RunnablePassthrough()&#125;</span><br><span class="line">        | prompt</span><br><span class="line">        | chat</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag_chain.invoke(<span class="string">&quot;What is Task Decomposition?&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Contextualizing-the-question-将问题置于背景中"><a href="#Contextualizing-the-question-将问题置于背景中" class="headerlink" title="Contextualizing the question 将问题置于背景中"></a>Contextualizing the question 将问题置于背景中</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将问题置于背景中</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> create_history_aware_retriever</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder</span><br><span class="line"></span><br><span class="line">contextualize_q_system_prompt = <span class="string">&quot;&quot;&quot;Given a chat history and the latest user question \</span></span><br><span class="line"><span class="string">which might reference context in the chat history, formulate a standalone question \</span></span><br><span class="line"><span class="string">which can be understood without the chat history. Do NOT answer the question, \</span></span><br><span class="line"><span class="string">just reformulate it if needed and otherwise return it as is.&quot;&quot;&quot;</span></span><br><span class="line">contextualize_q_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;system&quot;</span>, contextualize_q_system_prompt),</span><br><span class="line">        MessagesPlaceholder(<span class="string">&quot;chat_history&quot;</span>),</span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">history_aware_retriever = create_history_aware_retriever(</span><br><span class="line">    chat, retriever, contextualize_q_prompt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个链预先对检索器的输入查询进行改写，以便检索包含会话的上下文。</span></span><br></pre></td></tr></table></figure>

<h2 id="Chain-with-chat-history-带聊天记录的链"><a href="#Chain-with-chat-history-带聊天记录的链" class="headerlink" title="Chain with chat history 带聊天记录的链"></a>Chain with chat history 带聊天记录的链</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> create_retrieval_chain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents <span class="keyword">import</span> create_stuff_documents_chain</span><br><span class="line"></span><br><span class="line">qa_system_prompt = <span class="string">&quot;&quot;&quot;You are an assistant for question-answering tasks. \</span></span><br><span class="line"><span class="string">Use the following pieces of retrieved context to answer the question. \</span></span><br><span class="line"><span class="string">If you don&#x27;t know the answer, just say that you don&#x27;t know. \</span></span><br><span class="line"><span class="string">Use three sentences maximum and keep the answer concise.\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;context&#125;&quot;&quot;&quot;</span></span><br><span class="line">qa_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;system&quot;</span>, qa_system_prompt),</span><br><span class="line">        MessagesPlaceholder(<span class="string">&quot;chat_history&quot;</span>),</span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">question_answer_chain = create_stuff_documents_chain(chat, qa_prompt)</span><br><span class="line"></span><br><span class="line">rag_chain = create_retrieval_chain(history_aware_retriever, question_answer_chain)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage</span><br><span class="line"></span><br><span class="line">chat_history = []</span><br><span class="line"></span><br><span class="line">question = <span class="string">&quot;What is Task Decomposition?&quot;</span></span><br><span class="line">ai_msg_1 = rag_chain.invoke(&#123;<span class="string">&quot;input&quot;</span>: question, <span class="string">&quot;chat_history&quot;</span>: chat_history&#125;)</span><br><span class="line">chat_history.extend([HumanMessage(content=question), ai_msg_1[<span class="string">&quot;answer&quot;</span>]])</span><br><span class="line"></span><br><span class="line">second_question = <span class="string">&quot;What are common ways of doing it?&quot;</span></span><br><span class="line">ai_msg_2 = rag_chain.invoke(&#123;<span class="string">&quot;input&quot;</span>: second_question, <span class="string">&quot;chat_history&quot;</span>: chat_history&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ai_msg_2[<span class="string">&quot;answer&quot;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="所有必要的步骤都放在一个代码单元中"><a href="#所有必要的步骤都放在一个代码单元中" class="headerlink" title="所有必要的步骤都放在一个代码单元中"></a>所有必要的步骤都放在一个代码单元中</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> create_history_aware_retriever, create_retrieval_chain</span><br><span class="line"><span class="keyword">from</span> langchain.chains.combine_documents <span class="keyword">import</span> create_stuff_documents_chain</span><br><span class="line"><span class="keyword">from</span> langchain_community.chat_message_histories <span class="keyword">import</span> ChatMessageHistory</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> WebBaseLoader</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain_core.chat_history <span class="keyword">import</span> BaseChatMessageHistory</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder</span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables.history <span class="keyword">import</span> RunnableWithMessageHistory</span><br><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line"><span class="comment"># bs_strainer = bs4.SoupStrainer(class_=(&quot;post-content&quot;, &quot;post-title&quot;, &quot;post-header&quot;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Construct retriever ###</span></span><br><span class="line">loader = WebBaseLoader(</span><br><span class="line">    web_paths=(<span class="string">&quot;https://lilianweng.github.io/posts/2023-06-23-agent/&quot;</span>,),</span><br><span class="line">    bs_kwargs=<span class="built_in">dict</span>(</span><br><span class="line">        parse_only=bs4.SoupStrainer(</span><br><span class="line">            class_=(<span class="string">&quot;post-content&quot;</span>, <span class="string">&quot;post-title&quot;</span>, <span class="string">&quot;post-header&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">docs = loader.load()</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">200</span>)</span><br><span class="line">splits = text_splitter.split_documents(docs)</span><br><span class="line">vectorstore = Chroma.from_documents(documents=splits, embedding=embeddings)</span><br><span class="line">retriever = vectorstore.as_retriever()</span><br><span class="line"></span><br><span class="line"><span class="comment">### Contextualize question ###</span></span><br><span class="line">contextualize_q_system_prompt = <span class="string">&quot;&quot;&quot;Given a chat history and the latest user question \</span></span><br><span class="line"><span class="string">which might reference context in the chat history, formulate a standalone question \</span></span><br><span class="line"><span class="string">which can be understood without the chat history. Do NOT answer the question, \</span></span><br><span class="line"><span class="string">just reformulate it if needed and otherwise return it as is.&quot;&quot;&quot;</span></span><br><span class="line">contextualize_q_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;system&quot;</span>, contextualize_q_system_prompt),</span><br><span class="line">        MessagesPlaceholder(<span class="string">&quot;chat_history&quot;</span>),</span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">history_aware_retriever = create_history_aware_retriever(</span><br><span class="line">    chat, retriever, contextualize_q_prompt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Answer question ###</span></span><br><span class="line">qa_system_prompt = <span class="string">&quot;&quot;&quot;You are an assistant for question-answering tasks. \</span></span><br><span class="line"><span class="string">Use the following pieces of retrieved context to answer the question. \</span></span><br><span class="line"><span class="string">If you don&#x27;t know the answer, just say that you don&#x27;t know. \</span></span><br><span class="line"><span class="string">Use three sentences maximum and keep the answer concise.\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;context&#125;&quot;&quot;&quot;</span></span><br><span class="line">qa_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        (<span class="string">&quot;system&quot;</span>, qa_system_prompt),</span><br><span class="line">        MessagesPlaceholder(<span class="string">&quot;chat_history&quot;</span>),</span><br><span class="line">        (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line">question_answer_chain = create_stuff_documents_chain(chat, qa_prompt)</span><br><span class="line"></span><br><span class="line">rag_chain = create_retrieval_chain(history_aware_retriever, question_answer_chain)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Statefully manage chat history ###</span></span><br><span class="line">store = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_session_history</span>(<span class="params">session_id: <span class="built_in">str</span></span>) -&gt; BaseChatMessageHistory:</span><br><span class="line">    <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> store:</span><br><span class="line">        store[session_id] = ChatMessageHistory()</span><br><span class="line">    <span class="keyword">return</span> store[session_id]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conversational_rag_chain = RunnableWithMessageHistory(</span><br><span class="line">    rag_chain,</span><br><span class="line">    get_session_history,</span><br><span class="line">    input_messages_key=<span class="string">&quot;input&quot;</span>,</span><br><span class="line">    history_messages_key=<span class="string">&quot;chat_history&quot;</span>,</span><br><span class="line">    output_messages_key=<span class="string">&quot;answer&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conversational_rag_chain.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;What is Task Decomposition?&quot;</span>&#125;,</span><br><span class="line">    config=&#123;</span><br><span class="line">        <span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: <span class="string">&quot;abc123&quot;</span>&#125;</span><br><span class="line">    &#125;,  <span class="comment"># constructs a key &quot;abc123&quot; in `store`.</span></span><br><span class="line">)[<span class="string">&quot;answer&quot;</span>]</span><br><span class="line"></span><br><span class="line">conversational_rag_chain.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;What are common ways of doing it?&quot;</span>&#125;,</span><br><span class="line">    config=&#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;session_id&quot;</span>: <span class="string">&quot;abc123&quot;</span>&#125;&#125;,</span><br><span class="line">)[<span class="string">&quot;answer&quot;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain 完美兼容适配 MoonshotAI 国内AI，无需魔法即可调用，完美替代 OpenAI</title>
    <url>/article/112236.html</url>
    <content><![CDATA[<h1 id="必知概念"><a href="#必知概念" class="headerlink" title="必知概念"></a>必知概念</h1><p>官方概念：（地址：<a href="https://python.langchain.com)/">https://python.langchain.com）</a></p>
<p>LangChain是一个开发由语言模型驱动的应用程序的框架。它使应用程序能够：</p>
<ul>
<li>上下文感知：将语言模型连接到上下文源（提示指令、少量示例、响应内容等）</li>
<li>依靠语言模型进行推理（关于如何根据提供的上下文回答，采取什么行动等）</li>
</ul>
<blockquote>
<p><code>说人话</code>： 类似于Java的 SpringBoot 框架，而 LangChain 就是 AI 界的 “SpringBoot” 框架</p>
</blockquote>
<h1 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h1><p>创建<code>月之暗面</code>的 api 账号，<code>月之暗面 == MoonshotAI</code></p>
<p>官网地址：<a href="https://platform.moonshot.cn/">https://platform.moonshot.cn</a></p>
<p>现在注册新用户还会<code>赠送15元钱</code></p>
<table>
<thead>
<tr>
<th>模型</th>
<th>计费单位</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>moonshot-v1-8k</td>
<td>1M tokens</td>
<td>¥12.00</td>
</tr>
<tr>
<td>moonshot-v1-32k</td>
<td>1M tokens</td>
<td>¥24.00</td>
</tr>
<tr>
<td>moonshot-v1-128k</td>
<td>1M tokens</td>
<td>¥60.00</td>
</tr>
</tbody></table>
<blockquote>
<p>此处 1M &#x3D; 1,000,000</p>
</blockquote>
<p>价格比 OpenAI 的相当的实惠了，不过免费的 15 块已经可以用好久好久了</p>
<h1 id="必会代码"><a href="#必会代码" class="headerlink" title="必会代码"></a>必会代码</h1><blockquote>
<p>安装必要的依赖包</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -U langchain</span><br><span class="line">pip install -U langchain-openai</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MoonShotAI 完全兼容 OpenAI 接口</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    openai_api_base=<span class="string">&quot;https://api.moonshot.cn/v1/&quot;</span>,</span><br><span class="line">    openai_api_key=<span class="string">&quot;你刚申请的API-Key&quot;</span>,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(llm.invoke(<span class="string">&quot;请问你是我的小美吗?&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">content=&#x27;您好！我是MoonshotAI，一款由Moonshot Corp开发的人工智能助手。我可以帮助您回答问题和解决问题。请问有什么我可以帮助您的？&#x27; response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 31, &#x27;prompt_tokens&#x27;: 11, &#x27;total_tokens&#x27;: 42&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;api-key&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_BASE&quot;</span>] = <span class="string">&#x27;https://api.moonshot.cn/v1/&#x27;</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">base_url = os.getenv(<span class="string">&quot;OPENAI_API_BASE&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(api_key, base_url)</span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.5</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面就可以直接使用 LangChain 的相关依赖和方法了，下面演示一个例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic Example of a Prompt.</span></span><br><span class="line">response = llm.invoke(<span class="string">&quot;What are the 7 wonders of the world?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Response: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic Example of a Prompt Template.</span></span><br><span class="line">prompt_template = PromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;List &#123;n&#125; cooking recipe ideas &#123;cuisine&#125; cuisine (name only).&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt = prompt_template.<span class="built_in">format</span>(n=<span class="number">3</span>, cuisine=<span class="string">&quot;italian&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Templated Prompt: <span class="subst">&#123;prompt&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">response = llm.invoke(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Response: <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 llm 就是上面的 大模型实例</p>
</blockquote>
]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>MoonshotAI</tag>
        <tag>月之暗面</tag>
        <tag>kimi</tag>
      </tags>
  </entry>
  <entry>
    <title>Chat Models 聊天模型</title>
    <url>/article/112240.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>聊天模型是LangChain的核心组件。</p>
<p>聊天模型是一种语言模型，它使用聊天消息作为输入，并将聊天消息作为输出返回（而不是使用纯文本）。</p>
<p>LangChain与许多模型提供商（OpenAI、Cohere、Hugging Face等）集成，并公开了一个标准接口来与所有这些模型进行交互。</p>
<p>LangChain允许您在同步、异步、批处理和流模式下使用模型，并提供其他功能（例如，缓存）等。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;api-key&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_BASE&quot;</span>] = <span class="string">&#x27;https://api.moonshot.cn/v1/&#x27;</span></span><br><span class="line"></span><br><span class="line">api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">base_url = os.getenv(<span class="string">&quot;OPENAI_API_BASE&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(api_key, base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型(两种方式)：</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chat = ChatOpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">).bind(logprobs=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h1 id="chat-调用"><a href="#chat-调用" class="headerlink" title="chat 调用"></a>chat 调用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage, SystemMessage</span><br><span class="line"></span><br><span class="line">chat.invoke(</span><br><span class="line">    [</span><br><span class="line">        HumanMessage(</span><br><span class="line">            content=<span class="string">&quot;Translate this sentence from English to French: I love programming.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIMessage(content&#x3D;’J&#39;aime la programmation.\n\nIn this translation, “I love” is translated to “J&#39;aime” and “<br>programming” is translated to “la programmation.” The sentence structure remains the same as in English, with the<br>subject (I) followed by the verb (love) and then the object (programming).’, response_metadata&#x3D;{‘token_usage’:<br>{‘completion_tokens’: 68, ‘prompt_tokens’: 15, ‘total_tokens’: 83}, ‘model_name’: ‘moonshot-v1-8k’, ‘<br>system_fingerprint’: None, ‘finish_reason’: ‘stop’, ‘logprobs’: None})</p>
</blockquote>
<h1 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">messages = [</span><br><span class="line">    SystemMessage(</span><br><span class="line">        content=<span class="string">&quot;You are a helpful assistant that translates English to French.&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    HumanMessage(content=<span class="string">&quot;I love programming.&quot;</span>),</span><br><span class="line">]</span><br><span class="line">chat(messages)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIMessage(content&#x3D;”J’aime la programmation.”, response_metadata&#x3D;{‘token_usage’: {‘completion_tokens’: 8, ‘<br>prompt_tokens’: 20, ‘total_tokens’: 28}, ‘model_name’: ‘moonshot-v1-8k’, ‘system_fingerprint’: None, ‘<br>finish_reason’: ‘<br>stop’, ‘logprobs’: None})</p>
</blockquote>
<h2 id="批量方式"><a href="#批量方式" class="headerlink" title="批量方式"></a>批量方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_messages = [</span><br><span class="line">    [</span><br><span class="line">        SystemMessage(</span><br><span class="line">            content=<span class="string">&quot;You are a helpful assistant that translates English to chinese.&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        HumanMessage(content=<span class="string">&quot;I love programming.&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        SystemMessage(</span><br><span class="line">            content=<span class="string">&quot;You are a helpful assistant that translates English to chinese.&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        HumanMessage(content=<span class="string">&quot;I love artificial intelligence.&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">]</span><br><span class="line">result = chat.generate(batch_messages)</span><br><span class="line"><span class="comment"># 在Python中，当你想要在控制台中输出变量的值时，通常会使用 print 函数。但是，如果你在交互式环境（比如Python解释器或Jupyter Notebook）中执行这段代码，并且想要查看 result 的值，你可以直接输入变量名 result，而不需要使用 print 函数。</span></span><br><span class="line">result</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">LLMResult(generations=[[ChatGeneration(text=&#x27;我热爱编程。&#x27;, generation_info=&#123;&#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;, message=AIMessage(content=&#x27;我热爱编程。&#x27;, response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 5, &#x27;prompt_tokens&#x27;: 20, &#x27;total_tokens&#x27;: 25&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;))], [ChatGeneration(text=&#x27;我爱人工智能。&#x27;, generation_info=&#123;&#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;, message=AIMessage(content=&#x27;我爱人工智能。&#x27;, response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 4, &#x27;prompt_tokens&#x27;: 21, &#x27;total_tokens&#x27;: 25&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;))]], llm_output=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 9, &#x27;prompt_tokens&#x27;: 41, &#x27;total_tokens&#x27;: 50&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;&#125;, run=[RunInfo(run_id=UUID(&#x27;6eea2ab7-7faf-445c-8349-9cf471a862ec&#x27;)), RunInfo(run_id=UUID(&#x27;653c7159-bb9c-4ea6-ad18-c95aaaf65075&#x27;))])</span><br></pre></td></tr></table></figure>

<h1 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h1><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Caching 缓存</span></span><br><span class="line"><span class="comment"># LangChain为聊天模型提供了一个可选的缓存层。这很有用，原因有两个：</span></span><br><span class="line"><span class="comment"># 如果您经常多次请求相同的完成，它可以通过减少您向LLM提供商进行的 API 调用次数来为您节省资金。它可以通过减少您对LLM提供程序进行的 API 调用次数来加快应用程序的速度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In Memory Cache 内存缓存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;!-- ruff: noqa: F821 --&gt;</span></span><br><span class="line"><span class="keyword">from</span> langchain.<span class="built_in">globals</span> <span class="keyword">import</span> set_llm_cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># %time</span></span><br><span class="line"><span class="keyword">from</span> langchain.cache <span class="keyword">import</span> InMemoryCache</span><br><span class="line"></span><br><span class="line">set_llm_cache(InMemoryCache())</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first time, it is not yet in cache, so it should take longer</span></span><br><span class="line">chat.invoke(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU times: user 1 µs, sys: 0 ns, total: 1 µs</span><br><span class="line">Wall time: 4.77 µs</span><br><span class="line"></span><br><span class="line">AIMessage(content=&quot;Sure, here&#x27;s one for you:\n\nWhy did the tomato turn red?\n\nBecause it saw the salad dressing!&quot;, response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 23, &#x27;prompt_tokens&#x27;: 7, &#x27;total_tokens&#x27;: 30&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %time</span></span><br><span class="line"><span class="comment"># The second time it is, so it goes faster</span></span><br><span class="line">chat.invoke(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU times: user 1e+03 ns, sys: 0 ns, total: 1e+03 ns</span><br><span class="line">Wall time: 2.86 µs</span><br><span class="line"></span><br><span class="line">AIMessage(content=&quot;Sure, here&#x27;s one for you:\n\nWhy did the tomato turn red?\n\nBecause it saw the salad dressing!&quot;, response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 23, &#x27;prompt_tokens&#x27;: 7, &#x27;total_tokens&#x27;: 30&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第三方缓存（sqlite）"><a href="#第三方缓存（sqlite）" class="headerlink" title="第三方缓存（sqlite）"></a>第三方缓存（sqlite）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SQLite Cache SQLite缓存</span></span><br><span class="line"><span class="comment"># We can do the same thing with a SQLite cache</span></span><br><span class="line"><span class="keyword">from</span> langchain.cache <span class="keyword">import</span> SQLiteCache</span><br><span class="line"></span><br><span class="line">set_llm_cache(SQLiteCache(database_path=<span class="string">&quot;langchain.db&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %time</span></span><br><span class="line"><span class="comment"># The first time, it is not yet in cache, so it should take longer</span></span><br><span class="line">chat.invoke(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU times: user 1 µs, sys: 1 µs, total: 2 µs</span><br><span class="line">Wall time: 11 µs</span><br><span class="line"></span><br><span class="line">AIMessage(content=&quot;Sure, here&#x27;s one for you:\n\nWhy don&#x27;t scientists trust atoms?\n\nBecause they make up everything!&quot;, response_metadata=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 22, &#x27;prompt_tokens&#x27;: 7, &#x27;total_tokens&#x27;: 29&#125;, &#x27;model_name&#x27;: &#x27;moonshot-v1-8k&#x27;, &#x27;system_fingerprint&#x27;: None, &#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %time</span></span><br><span class="line"><span class="comment"># The second time it is, so it goes faster</span></span><br><span class="line">chat.invoke(<span class="string">&quot;Tell me a joke&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">AIMessage(content=&quot;Sure, here&#x27;s one for you:\n\nWhy don&#x27;t scientists trust atoms?\n\nBecause they make up everything!&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>LangChain LCEL 链式调用</title>
    <url>/article/112237.html</url>
    <content><![CDATA[<h1 id="准备大模型实例"><a href="#准备大模型实例" class="headerlink" title="准备大模型实例"></a>准备大模型实例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;moonshot api key&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_BASE&quot;</span>] = <span class="string">&#x27;https://api.moonshot.cn/v1/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">base_url = os.getenv(<span class="string">&quot;OPENAI_API_BASE&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(api_key, base_url)</span><br><span class="line"></span><br><span class="line">model = ChatOpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">1</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"></span><br><span class="line">prompt1 = ChatPromptTemplate.from_template(<span class="string">&quot;what is the city &#123;person&#125; is from?&quot;</span>)</span><br><span class="line">prompt2 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;what country is the city &#123;city&#125; in? respond in &#123;language&#125;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chain1 = prompt1 | model | StrOutputParser()</span><br><span class="line"></span><br><span class="line">chain2 = (</span><br><span class="line">        &#123;<span class="string">&quot;city&quot;</span>: chain1, <span class="string">&quot;language&quot;</span>: itemgetter(<span class="string">&quot;language&quot;</span>)&#125;</span><br><span class="line">        | prompt2</span><br><span class="line">        | model</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调用1"><a href="#调用1" class="headerlink" title="调用1"></a>调用1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chain2.invoke(&#123;<span class="string">&quot;person&quot;</span>: <span class="string">&quot;小美&quot;</span>, <span class="string">&quot;language&quot;</span>: <span class="string">&quot;中文&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>‘根据对话中提供的信息，小美来自中国。具体来说，她提到她来自中国的“大城市”。由于对话中没有明确提及，所以不清楚她具体来自哪个城市。’</p>
</blockquote>
<h1 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough</span><br><span class="line"></span><br><span class="line">prompt1 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;generate a &#123;attribute&#125; color. Return the name of the color and nothing else:&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt2 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;what is a fruit of color: &#123;color&#125;. Return the name of the fruit and nothing else:&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt3 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;what is a country with a flag that has the color: &#123;color&#125;. Return the name of the country and nothing else:&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt4 = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;What is the color of &#123;fruit&#125; and the flag of &#123;country&#125;?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model_parser = model | StrOutputParser()</span><br><span class="line"></span><br><span class="line">color_generator = (</span><br><span class="line">        &#123;<span class="string">&quot;attribute&quot;</span>: RunnablePassthrough()&#125; | prompt1 | &#123;<span class="string">&quot;color&quot;</span>: model_parser&#125;</span><br><span class="line">)</span><br><span class="line">color_to_fruit = prompt2 | model_parser</span><br><span class="line">color_to_country = prompt3 | model_parser</span><br><span class="line">question_generator = (</span><br><span class="line">        color_generator | &#123;<span class="string">&quot;fruit&quot;</span>: color_to_fruit, <span class="string">&quot;country&quot;</span>: color_to_country&#125; | prompt4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="调用1-1"><a href="#调用1-1" class="headerlink" title="调用1"></a>调用1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question_generator.invoke(<span class="string">&quot;warm&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ChatPromptValue(messages&#x3D;[HumanMessage(content&#x3D;’What is the color of Peach and the flag of Georgia?’)])</p>
</blockquote>
<h2 id="调用2"><a href="#调用2" class="headerlink" title="调用2"></a>调用2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = question_generator.invoke(<span class="string">&quot;warm&quot;</span>)</span><br><span class="line">model.invoke(prompt)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIMessage(content&#x3D;”The color of a peach can vary depending on its ripeness. Generally, a ripe peach is characterized<br>by a warm, yellow-orange hue with some variations of red or pink shades on its skin. These colors give the fruit an<br>appealing and vibrant appearance.\n\nThe flag of Georgia, referring to the U.S. state and not to the country located<br>at<br>the intersection of Europe and Asia, consists of three equal horizontal bands. The colors of the bands are as follows:<br>\n\n1. Top band: Dark red - this represents the courage and determination of the people of Georgia.\n2. Middle band:<br>White - this symbolizes the mountain peaks and the virtue of purity in the state.\n3. Bottom band: Sky blue - this<br>signifies the Georgia state’s hospitality and staying power.\n\nIn summary, the color of a ripe peach typically<br>consists<br>of yellow-orange, red, or pink shades, while the flag of Georgia, the U.S. state, comprises dark red, white, and sky<br>blue bands.”, response_metadata&#x3D;{‘token_usage’: {‘completion_tokens’: 198, ‘prompt_tokens’: 15, ‘total_tokens’:<br>213}, ‘<br>model_name’: ‘moonshot-v1-8k’, ‘system_fingerprint’: None, ‘finish_reason’: ‘stop’, ‘logprobs’: None})</p>
</blockquote>
<h1 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">planner = (</span><br><span class="line">        ChatPromptTemplate.from_template(<span class="string">&quot;生成关于: &#123;input&#125;的论点&quot;</span>)</span><br><span class="line">        | model</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">        | &#123;<span class="string">&quot;base_response&quot;</span>: RunnablePassthrough()&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">arguments_for = (</span><br><span class="line">        ChatPromptTemplate.from_template(</span><br><span class="line">            <span class="string">&quot;列出 &#123;base_response&#125; 的优点或积极方面&quot;</span></span><br><span class="line">        )</span><br><span class="line">        | model</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line">arguments_against = (</span><br><span class="line">        ChatPromptTemplate.from_template(</span><br><span class="line">            <span class="string">&quot;列出 &#123;base_response&#125; 的缺点或负面方面&quot;</span></span><br><span class="line">        )</span><br><span class="line">        | model</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">final_responder = (</span><br><span class="line">        ChatPromptTemplate.from_messages(</span><br><span class="line">            [</span><br><span class="line">                (<span class="string">&quot;ai&quot;</span>, <span class="string">&quot;&#123;original_response&#125;&quot;</span>),</span><br><span class="line">                (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;Pros:\n&#123;results_1&#125;\n\nCons:\n&#123;results_2&#125;&quot;</span>),</span><br><span class="line">                (<span class="string">&quot;system&quot;</span>, <span class="string">&quot;根据批评生成一个最终回应&quot;</span>),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        | model</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chain = (</span><br><span class="line">        planner</span><br><span class="line">        | &#123;</span><br><span class="line">            <span class="string">&quot;results_1&quot;</span>: arguments_for,</span><br><span class="line">            <span class="string">&quot;results_2&quot;</span>: arguments_against,</span><br><span class="line">            <span class="string">&quot;original_response&quot;</span>: itemgetter(<span class="string">&quot;base_response&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        | final_responder</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># itemgetter 作为从映射中提取数据的简写</span></span><br><span class="line"></span><br><span class="line">chain.invoke(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;内卷&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内卷现象作为一个复杂的社会现象，既包含了一定的积极作用，也带来了许多负面影响。在应对内卷现象时，我们应该全面地认识其正反两面，采取有力的措施来平衡这些利弊，引导社会走向更加健康和谐的发展道路。<br>首先，我们应该正视内卷现象带来的心理健康问题、人际关系紧张、工作与生活失衡等问题。政府、企业和教育机构需要共同努力，通过制定合理的政策、关注员工福利、培养学生的创新能力和批判性思维等措施，来减轻内卷现象带来的负面影响。<br>同时，我们也应该看到内卷现象在一定程度上激发了人们的勤奋努力、提高竞争力和创新能力。因此，在应对内卷现象时，我们应该鼓励人们充分发挥自己的特长，关注个体差异，从而推动社会的多元化发展。<br>此外，社会各界应该共同努力提高人们的心理素质，关注心理健康问题，帮助人们在面对竞争和压力时保持良好的心态。同时，我们需要提高人们对教育、工作和生活品质的认识，使人们在追求物质生活和职业成功的同时，不忘关注家庭、友情等生活的重要方面。<br>总之，内卷现象作为一个具有双重性的社会现象，我们应该在全面认识其利弊的基础上，采取有效的措施来应对挑战，促进社会的平衡、健康和可持续发展。</p>
</blockquote>
]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>MoonshotAI</tag>
        <tag>月之暗面</tag>
        <tag>kimi</tag>
        <tag>chain</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将多个提示(prompts)组合在一起</title>
    <url>/article/112239.html</url>
    <content><![CDATA[<h1 id="如何将多个提示组合在一起。"><a href="#如何将多个提示组合在一起。" class="headerlink" title="如何将多个提示组合在一起。"></a>如何将多个提示组合在一起。</h1><p>当您想要重用部分提示时，这可能很有用。这可以通过 PipelinePrompt 完成。PipelinePrompt 由两个主要部分组成：</p>
<ul>
<li>最终提示：返回的最后一个提示</li>
<li>管道提示：元组列表，由字符串名称和提示模板组成。每个提示模板都将被格式化，然后作为同名变量传递给将来的提示模板。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pipeline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.prompts.pipeline <span class="keyword">import</span> PipelinePromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.prompt <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">full_template = <span class="string">&quot;&quot;&quot;&#123;introduction&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;example&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;start&#125;&quot;&quot;&quot;</span></span><br><span class="line">full_prompt = PromptTemplate.from_template(full_template)</span><br><span class="line"></span><br><span class="line">introduction_template = <span class="string">&quot;&quot;&quot;You are impersonating &#123;person&#125;.&quot;&quot;&quot;</span></span><br><span class="line">introduction_prompt = PromptTemplate.from_template(introduction_template)</span><br><span class="line"></span><br><span class="line">example_template = <span class="string">&quot;&quot;&quot;Here&#x27;s an example of an interaction:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: &#123;example_q&#125;</span></span><br><span class="line"><span class="string">A: &#123;example_a&#125;&quot;&quot;&quot;</span></span><br><span class="line">example_prompt = PromptTemplate.from_template(example_template)</span><br><span class="line"></span><br><span class="line">start_template = <span class="string">&quot;&quot;&quot;Now, do this for real!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: &#123;input&#125;</span></span><br><span class="line"><span class="string">A:&quot;&quot;&quot;</span></span><br><span class="line">start_prompt = PromptTemplate.from_template(start_template)</span><br><span class="line"></span><br><span class="line">input_prompts = [</span><br><span class="line">    (<span class="string">&quot;introduction&quot;</span>, introduction_prompt),</span><br><span class="line">    (<span class="string">&quot;example&quot;</span>, example_prompt),</span><br><span class="line">    (<span class="string">&quot;start&quot;</span>, start_prompt),</span><br><span class="line">]</span><br><span class="line">pipeline_prompt = PipelinePromptTemplate(</span><br><span class="line">    final_prompt=full_prompt, pipeline_prompts=input_prompts</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pipeline_prompt.input_variables</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[‘person’, ‘input’, ‘example_q’, ‘example_a’]</p>
</blockquote>
<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    pipeline_prompt.<span class="built_in">format</span>(</span><br><span class="line">        person=<span class="string">&quot;Elon Musk&quot;</span>,</span><br><span class="line">        example_q=<span class="string">&quot;What&#x27;s your favorite car?&quot;</span>,</span><br><span class="line">        example_a=<span class="string">&quot;Tesla&quot;</span>,</span><br><span class="line">        <span class="built_in">input</span>=<span class="string">&quot;What&#x27;s your favorite social media site?&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">You are impersonating Elon Musk.</span><br><span class="line"></span><br><span class="line">Here&#x27;s an example of an interaction:</span><br><span class="line"></span><br><span class="line">Q: What&#x27;s your favorite car?</span><br><span class="line">A: Tesla</span><br><span class="line"></span><br><span class="line">Now, do this for real!</span><br><span class="line"></span><br><span class="line">Q: What&#x27;s your favorite social media site?</span><br><span class="line">A:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>prompt</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-04-13 日常记录</title>
    <url>/article/112245.html</url>
    <content><![CDATA[<h1 id="大悦城"><a href="#大悦城" class="headerlink" title="大悦城"></a>大悦城</h1><h2 id="温柔可爱的小猫咪"><a href="#温柔可爱的小猫咪" class="headerlink" title="温柔可爱的小猫咪"></a>温柔可爱的小猫咪</h2><p><img src="https://img.funning.top/24-4-13-6.jpg"></p>
<h2 id="麻辣爽口的美味菜"><a href="#麻辣爽口的美味菜" class="headerlink" title="麻辣爽口的美味菜"></a>麻辣爽口的美味菜</h2><p><img src="https://img.funning.top/24-4-13-1.jpg"><br><img src="https://img.funning.top/24-4-13-2.jpg"><br><img src="https://img.funning.top/24-4-13-3.jpg"><br><img src="https://img.funning.top/24-4-13-4.jpg"><br><img src="https://img.funning.top/24-4-13-5.jpg"></p>
]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>Q&amp;A RAG 快速入门</title>
    <url>/article/112243.html</url>
    <content><![CDATA[<h1 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h1><p>RAG 全称：Retrieval-Augmented Generation<br>RAG 是一种使用额外数据增强LLM知识的技术。</p>
<p>最强大的应用程序LLMs之一是复杂的问答 （Q&amp;A） 聊天机器人。这些应用程序可以回答有关特定源信息的问题。这些应用程序使用一种称为检索增强生成<br>（RAG） 的技术。</p>
<p>LLMs可以对广泛的主题进行推理，但他们的知识仅限于公共数据，直到他们接受培训的特定时间点。如果要构建可以推理私有数据或模型截止日期后引入的数据的<br>AI 应用程序，则需要使用模型所需的特定信息来增强模型的知识。引入适当信息并将其插入模型提示符的过程称为检索增强生成 （RAG）。</p>
<h1 id="RAG-架构"><a href="#RAG-架构" class="headerlink" title="RAG 架构"></a>RAG 架构</h1><p>典型的 RAG 应用程序有两个主要组件：</p>
<p>索引：用于从源引入数据并对其进行索引的管道。这通常发生在离线状态。</p>
<p>检索和生成：实际的 RAG 链，它在运行时接受用户查询并从索引中检索相关数据，然后将其传递给模型。</p>
<h2 id="Indexing-索引"><a href="#Indexing-索引" class="headerlink" title="Indexing 索引"></a>Indexing 索引</h2><p>加载：首先我们需要加载数据。这是使用 DocumentLoaders 完成的。</p>
<p>拆分：文本拆分器将大 Documents 块拆分为更小的块。这对于索引数据和将数据传递到模型都很有用，因为大块更难搜索，并且不适合模型的有限上下文窗口。</p>
<p>存储：我们需要某个地方来存储和索引我们的拆分，以便以后可以搜索它们。这通常是使用 VectorStore 和 Embeddings 模型完成的。</p>
<p><img src="https://img.funning.top/rag_indexing.png"></p>
<h2 id="Retrieval-and-generation-检索和生成"><a href="#Retrieval-and-generation-检索和生成" class="headerlink" title="Retrieval and generation 检索和生成"></a>Retrieval and generation 检索和生成</h2><p>检索：给定用户输入，使用 Retriever 从存储中检索相关拆分。</p>
<p>生成：ChatModel &#x2F; LLM 使用包含问题和检索数据的提示生成答案</p>
<p><img src="https://img.funning.top/rag_retrieval_generation.png"></p>
<h1 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h1><h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;your key&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_BASE&quot;</span>] = <span class="string">&#x27;https://api.moonshot.cn/v1/&#x27;</span></span><br><span class="line"></span><br><span class="line">api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">base_url = os.getenv(<span class="string">&quot;OPENAI_API_BASE&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;api_key=&quot;</span> + api_key, <span class="string">&quot;base_url=&quot;</span> + base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型(两种方式)：</span></span><br><span class="line"></span><br><span class="line">llm = OpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chat = ChatOpenAI(</span><br><span class="line">    openai_api_base=base_url,</span><br><span class="line">    openai_api_key=api_key,</span><br><span class="line">    model_name=<span class="string">&quot;moonshot-v1-8k&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.7</span>,</span><br><span class="line">).bind(logprobs=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="向量化-初始化"><a href="#向量化-初始化" class="headerlink" title="向量化 初始化"></a>向量化 初始化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> SentenceTransformerEmbeddings</span><br><span class="line"></span><br><span class="line">embeddings = SentenceTransformerEmbeddings(model_name=<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="所需依赖准备"><a href="#所需依赖准备" class="headerlink" title="所需依赖准备"></a>所需依赖准备</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BeautifulSoup (通常缩写为：BS4)  用于解析 HTML 和 XML 文件。它提供了从 HTML 和 XML 文档中提取数据的功能，以及对解析树进行导航的工具。</span></span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> hub</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> WebBaseLoader</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough</span><br><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br></pre></td></tr></table></figure>

<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load, chunk and index the contents of the blog.</span></span><br><span class="line">loader = WebBaseLoader(</span><br><span class="line">    web_paths=(<span class="string">&quot;https://lilianweng.github.io/posts/2023-06-23-agent/&quot;</span>,),</span><br><span class="line">    bs_kwargs=<span class="built_in">dict</span>(</span><br><span class="line">        parse_only=bs4.SoupStrainer(</span><br><span class="line">            class_=(<span class="string">&quot;post-content&quot;</span>, <span class="string">&quot;post-title&quot;</span>, <span class="string">&quot;post-header&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">docs = loader.load()</span><br><span class="line"></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">100</span>, chunk_overlap=<span class="number">20</span>)</span><br><span class="line">splits = text_splitter.split_documents(docs)</span><br><span class="line">vectorstore = Chroma.from_documents(documents=splits, embedding=embeddings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve and generate using the relevant snippets of the blog.</span></span><br><span class="line"><span class="comment"># retriever = vectorstore.as_retriever(search_type=&quot;similarity&quot;, search_kwargs=&#123;&quot;k&quot;: 6&#125;)</span></span><br><span class="line">retriever = vectorstore.as_retriever()</span><br><span class="line"><span class="comment"># 提取名为 rlm/rag-prompt 的资源。</span></span><br><span class="line">prompt = hub.pull(<span class="string">&quot;rlm/rag-prompt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_docs</span>(<span class="params">docs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n\n&quot;</span>.join(doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> docs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rag_chain = (</span><br><span class="line">        &#123;<span class="string">&quot;context&quot;</span>: retriever | format_docs, <span class="string">&quot;question&quot;</span>: RunnablePassthrough()&#125;</span><br><span class="line">        | prompt</span><br><span class="line">        | chat</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="invoke调用"><a href="#invoke调用" class="headerlink" title="invoke调用"></a>invoke调用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rag_chain.invoke(<span class="string">&quot;What is Task Decomposition?&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;Task Decomposition is a process that breaks down complex tasks into smaller, simpler steps. It utilizes techniques such as Chain of Thought, which instructs the model to think step by step, transforming difficult tasks into manageable ones and providing insight into the model&#x27;s thought process. This can be achieved through simple prompting, task-specific instructions, or human inputs, and can be extended by exploring multiple reasoning possibilities using Tree of Thoughts.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Stream-式输出"><a href="#Stream-式输出" class="headerlink" title="Stream 式输出"></a>Stream 式输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> rag_chain.stream(<span class="string">&quot;What is Task Decomposition?&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(chunk, end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自定义-prompt"><a href="#自定义-prompt" class="headerlink" title="自定义 prompt"></a>自定义 prompt</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;Use the following pieces of context to answer the question at the end.</span></span><br><span class="line"><span class="string">If you don&#x27;t know the answer, just say that you don&#x27;t know, don&#x27;t try to make up an answer.</span></span><br><span class="line"><span class="string">Use three sentences maximum and keep the answer as concise as possible.</span></span><br><span class="line"><span class="string">Always say &quot;thanks for asking!&quot; at the end of the answer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: &#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Helpful Answer:&quot;&quot;&quot;</span></span><br><span class="line">custom_rag_prompt = PromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line">rag_chain = (</span><br><span class="line">        &#123;<span class="string">&quot;context&quot;</span>: retriever | format_docs, <span class="string">&quot;question&quot;</span>: RunnablePassthrough()&#125;</span><br><span class="line">        | custom_rag_prompt</span><br><span class="line">        | chat</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rag_chain.invoke(<span class="string">&quot;What is Task Decomposition?&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;Task decomposition involves breaking down complex tasks into smaller, more manageable subgoals. It helps in making it easier to understand, plan, and execute the overall task. This approach is useful in various fields, including project management, programming, and artificial intelligence.\n\nChallenges in long-term planning and task decomposition include managing dependencies between subgoals, coordinating resources, and adapting to changing circumstances. Addressing these challenges can lead to more efficient and effective task completion.\n\nThanks for asking!&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AI</category>
        <category>LLM</category>
        <category>LangChain</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大语言模型</tag>
        <tag>LangChain</tag>
        <tag>RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>香港澳门旅游</title>
    <url>/article/112224.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2114a8e8e51478fa0a6868948772525d6cd3a1cb9dfa6a78d8aad5e5913947c5">234db99cd52a97edc76dee15a0b78a9cfbb2fe72764757b7bf506403d2181f91e83e4da17640f2ceae9783073b7bc0b166891eec70ccebc480ce813bc01236e2c9dd1707a7654171e7e58de0e34a56e63fbcf90a4ad6625f117ae7e6509a29ca1b45416cfde1bde438f01ca966b4946f2a1365c378e1a34065d0603c9bc122558d4df4bfe65a0d01c97b5eb40ee0c23a9643bb78c7d30612d3c7a942a9d30ca90f29b662cc6b23c9ca2c2943c91f7c8a12f225982506a9c88d3c960da248e3f60e22dfc4c212a3e4ee6669773174795b0a1b1c6d9eb1feab82bf1d870b5b4b94f9e000d630f896c127b86f897695783c01b9bf9f93b3a43e4c2a7b24755ab482a663a57daf36a0b4d33158d112296117ed2bb4cbd205236c779976795c3ed0d71e297b09de7ee96bd0a5140bb21cf74a03f706c37b25dc3222933d4440bee09a6f2b9fbf521c0175ba86828aef1da182d53bbf246330664509e424b75491c1cd214a1f4257ece26708ec6b5b599dafed0d658a5e20804d3c52962ab44b6a05b904d7bfba555d2c685d585c359455bc95c5c9e7b8b2424be2a801d4f21d7d46077e3637b5574e28990a23de44ac5279667cbb66bd3bb152d446e5a6f8e756b16e0eb87be84a909ca8db3b7661c79b21c3fb53fa8724a3aac6ad28ae5b61f0e58cc992c02f7d826289310993ad03684e64d85aebbca08c9e511a854cb4d7040dc369e6852742f48c3f9008018f26c0059acc70e2c39c7d6c61534ea35e4e5d0414e55173713183df7b2742bdc0b31369663cd16974a6458dbc5f42ea33a0ebc00bb8b20596b28e80496d5fc473455197be41935622e7fcd048fb2591f441b16ae253e6b8e08b1e561f6aee3a611ebde612086e73d2b3df961c78177e902b8b92180bb4a4d8b0ee45932bb3d384aa4db20f239e99ded5c63390afae3de96f60ba6c735df3647625a4093750e43561e8ceebe7633fc3c9fa43636ca3cd34550f3f572db52cec5754f1042f13025513506a7d765d15c1c67d8890c5fe4f5f0ac300d004799a484aae0e983ce7965a40131674eb20d7ee800ba198c32c8aafb140e4fd2573fefd7390d800156814c0f30f8ccddd39da1d2080fb9193214f508d631ad62015b534ba9508fc7442ec171a79d4458eb7c13bc0eccc03427e6b3eaa8e74731c851b414ce7df1d4d6959d716fe314ec624d1e25d2564a8e156ffadb0da2586eedc22b399ae7dcb0d87bbfd777583174a77758d265d9be84aefb10053cfa653b57081d3239a6aed47d993b90dceb579af1dac21657caad26175728b0c876cdf4526d4cf46f1e5a8e8c6fc96792f9f39818daeed467406fdc890526f802c2e896d35622e10e766c2c229cefd3c626ecc647bcf628d395b03ef8ff18d84757d036fa102f6c37ca0199054195fe2db0519385eed164880beee22556ae1164f2b6965a9499f647dda28e7347e28c062cac8dbd8f8c66e728ef6f65965d1c05fdfbc26f697af0d36e9f7e227882e243e505d6bc973d7f20db82e87dd5e29480ba26849f4bef16d6a41dfe64d6adc159617ef6a37bf9dce5fd4b90e87cbbf2273cd084620cf96ec281231cd5d3967e775dcecbd5154c8061f2e130cdc1ab10861c586d0610b61d20f906b3ac748cc2b25703f67eda405a86aaeb83df9e675f0b4c46dd52e45fd57636f6a0cd23770edbec84776248f94bbdcfe78ccca665e0c890c99ff886cff4f6057c7e8855e7319b83fcd02af9bbeb0a4e5c18b107eff660458a0a69e148b2f23108ee68d77d1e1a60294feace01d7719b9df135fe971450f6d50e11a649d5346708aa9c51912d6e02330743992e767f7aab79df15ccc0807c1c6e5f8a742f9483162be5792c61e8174e53ad8d6570540b2d07d87b01b807be34eae496602f680626b95e5d0bce725f57a5c9788cb1b04ab4df23b04838ac96c30ceb5dea1e519587b555cf79114148919226ede8e2a0a621b59201b4a0c58b9a9791d14229a0976fa10dd3c360673ab3398cda63153aab6d31a912ec3da91d9cb9f4de0a623236706b5a505f4606e2dcaae4ce948f8c7e619aa3d57e4fab319dbfd576279f1e4a5db20daa678bc3539f6c4e8ae1c06effcaec65be0152916a6a53b295466f7acddab9cdae3bef7c9abc86fc53c25d8b225a8b3e66ad69160262d3d1fd98261403af5cd0d4129053c63febefcfefae7988f1c2b9b5dfd8f9a177657e43c76584171066479ba8c56260401157b3ff39016ef78b4c87d7de7a295a0aa4175957e312cd94cda38db19e469877cc74d6c0e5e1c3cc7cbeb37399ee4bdfc9c19e035dc439d9fae79077feba7fc7c0a2542560cd4628ed59f7769378fa95551331a39f442e1678e076212db866c8c0747361791352c0e24030978150a6a5300c5124c45988e7474b85a380d765b9331fa5d4883e8214bc588a72538ef973aa6775325d071090a21f77c10b700ed2ffc884879c7e9400819e81565fbbb2a5673301a880d831f7f5189951c574f8fd84c58171fdce497fc1cb78260e50d7949d1cf1c99a1eef2e0f5c4d8a0fd3d01d6bd5d4161f0edc26906f3d7601c6d4d8eb0abb4507113516c173d954de58da55ca2940dc4d95f1a06fb23a30cf8e7102037d60f1433d03c1956499c64872719078f9db30de0a110e56c52893ebccee1f1340533080d112ae47f04800d88a0fa8553d36873beb8ccc9ccf83f5947aae6734823a7e1a08339ce9ddc73e1c475743f7682a1834498f757a720e3a95bc3c7ae2743bfa4f8b404679bdbd1e60f2d8e059b617db622e20da0077fabe689f0f2b124470297b359041f5d65d5b94fc0450df8a27679ee54decef489e08f9b8f68d97a25b40ef1b3fe79e94cfa960f5d656a48b1e6977e139755ddb438114f6432a9064f533139dcf311cf0eb4a9c9559f81a018ad71fdaeca688107ee24367e9cbff705880d9100a9d986fab17717fa8d6e2227ac50a8279cee7d9da68d8c9d8d5d1db1e1d48207f00ccc5847131108103a7bc523b3e227abbdfd44025a039946d50dcb22e2a2ffe316b0dcec5942bfcc1ff2a3596e68f65e1dc6cb3929a1626a03c96b68e87453ecd42d2017049c4e921a973df7846569e3bd9beabdfbbda9cf87bbc6dc4584243ccd706ec559520eec2de4598481a64bdf5149eead88eb445c864391095e066b6cc06db39ebc06e53724aaa4cfa6efac08cbb897db40b5eba41666d969c1c0d0ac77df9ad3b5464b7d70d848a00a038f88f36a8f148d0b9f5b2396e72957260f96002e7b2a1165869ad17bdcd8495bba87a30ecff621b7308cc86d7c9637075e189c4ca2090f9975638cf8a1b8086c3c4de4c534c5a5f96dd08970f65546d10fce72cd488805250a12eabae1e4e587c0b2e1aa851f6910440be1160d199703dfb69608e187ca013eeb01d6d4b4bb884ff3c04ba88127d7c20119a23156eba9deaece0fee313b534cc25ac4a2aeb8eb89bdadfeb629a7610085af58443def5b2bf7fe53c8957e06471f4bde0db6226f33282243ea49ed57b8ae8e620f18ad55c34c64d32d26270c005297d75d72f1f446d663cecbf8b5e713a98dc5d4d1de827e0f18f5c6dd02fc3f6a7642f19910f93726d6daa49254848c296d24088e1fe74e4bd8b0172715cc3c9f47c01850c294fee4e2822144670a58bc4ceea84a5fe66acfe29f95aa032e3953b130b0f3b9c464d670f71b88549a762e130737ec1f94ad515b621d835e9984f8e7c811f200ddca24bf05c86d83263d9693713035cad677cc84ddc5be0a6f04bf1cc157aaf7fddd53786ebd46850d002e2639d05be0c9dbe30290201727caab0224a63f5abc738931ebec8dc893252686bbde82653e0e19752c6d33a156be37a6ef0693d18c2543adb8f2cf9d6f3b9638e10784a6d50597da79fbffffa879d71801d5c7a0b5d7b7ab53c371891fa5efc7e876a9fdf0846a340521973a7a28c4517daa4a0630c7d0d0e40ad092f4800d1d669bc6bd2f65334d5a00d0f002d6deb4b913720904e73f1a8360485ad308d732a66eff3beae216904c97b955bc2d6abc1164b31d41005e4a62cfbea6d2135fb860bc7d645d9d72dcddea8e60761e824f0d9f6623a90c06cf8a2637c47486e3487b880c789e621eabbbb632d42e9418900de27da4c8ed17971bff6a9510f29349bfa9657b991789a45b2dfe59fd62398d1f573292688482257652dab1fc97d26a42eb5f0fb4f431aa03c7b8a65a0fa736dad733a8a0646b1d1d1fb9cc57f77b4c76e9614544c6e061fc97e8b8a5096eda860c15054e4ee365be34fd24de02216862e6c3c95c69edf92ae6e37948c48d1ac7249c74650ff23492d75d624400974e3e9bb7e460050ff27e8a6d7762c4ff440032aeb9b02c0a107398f0d2bb3b6ec8ead6fe67f36b7103809d6f6f5081a8edeb17e103c33626e834819f0827fcefde88cce351e8eba78435a9b2e4d0c40e0aae64f0dc6ae60822473a6226afd019c17aa3ed81180a19d0d79a24655ff7c7789f9c38f5603a9242e7a3afbe73219f94cce849354d53e28b98c61009357309d852535c6e7f297a17439c6c0416e1be5bf639e4d608eea25233192b55e36ac0c1eba64ad52b67c95b0562e061e2185cec8fa00fa7bc888d0422b8892e8ef168933a785a36eaf7b5741ca55c2fb43ac727f9584d870c96a64d26fc2de1585af0a4461143f2a3099ce2b118f097983e3004818c322b108aacb6c9de2e8fa3a1b31106f9d780919f7f52c86cd37fda08f3cbe16b398ea359ad1f309bae07c7d0243ce08a8ebd0850e63ad059c64416d09c7129150e9ddc7f73f055fa8fa23d6324f50b5848287f8194b46fd3c43894f43eb67c51d79189f9132944c7603c1af0a3e1f9ebc618f16d4d2852fef8278abca3afabf7ecddf2b072f565872408c07a5e656039600c6d6546ac020a613a18927d168ea8cd12451c7a18724340330d8b09d71f016dabadf8727b0624cdfc8eeffadc863a9bae63c64336dd10fb6a89366dacc43a5817091197c7266276a06a80372d3fc0ab7390e5dcb551240e1faecb854ba0d83a965c25bbe175aa2ccde9951de68c28ff39d79d4cc7c49740bd471c75ac816ebe1f39a05005db5d7040f1de3f726ba5877c021d70adf58374cfc0b831ffb31f6cbe98b3db5fc6c9aaaf7e0342a10a744845176dc17e0f688a6ef3f004cfeeaf0e1fd8d5ed163eb920b6c00c44f018e9ed81a29cc783f70dea6030769f101a729cafe12499036664545f636275cb0ba8f3950f5ad3840c13b239a1fae686dbbe5fda3e265ab53645ac2bb9d13154e284faefc83615233a0e335c9168be1d4dbb7f3af895510d5bd85b7e4948e1e0f4800f4669d85a951dec252686f8e2c2f69c1baf67df1805b8ca6df7bb3183d0c3fcfff1c600822c55e9323b402be687e4bce29db2985c49191c9b57752fa70ea0cabe75cf3f31ded680daeb3304bf31fc0688e3034c9e14c932a9d5fa0294b6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>旅游</category>
        <category>攻略</category>
      </categories>
      <tags>
        <tag>攻略</tag>
        <tag>澳门</tag>
        <tag>旅游</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>《掌纹深处的人生密码》深度解读隐藏在手相中的命运密码</title>
    <url>/article/112249.html</url>
    <content><![CDATA[<p>手相，也称为掌相学或手纹解读，是一种古老的传统占卜技巧，通过观察、分析一个人的手部特别是手掌纹路来推测他们的性格、命运以及潜在的生活趋势。<br>手相学认为，人的手尤其是指纹包含了生命的信息和指引，认为这些纹理包含了遗传特征和环境对性格的影响。</p>
<p>主要关注以下几个方面：</p>
<ul>
<li>手指长度和形状：反映了个人的独立性、社交能力或创造力。</li>
<li>掌纹 - 包括生命线、爱情线、太阳线等。生命线通常表示寿命，情感线代表人际关系，太阳线则可能指示财富或成就。</li>
<li>手指关节线、皱纹和标记：可以反映个体的性格特点，如坚强、柔软、决策果断等。</li>
<li>手的掌肉和纹理：如指纹类型（如斗型、箕型、混合等）被认为揭示了个性的不同侧面。</li>
</ul>
<p>尽管科学界普遍认为手相并没有可信的科学依据，而是一种民俗文化信仰，但在一些所谓的占星学、心理学甚至自我发现的圈子中，人们依然会在日常生活中运用它作为一种寄托、自我认知或娱乐方式。<br>请注意，任何解读都应保持宽泛和理性，<code>不应将其作为决定未来的唯一依据</code>。</p>
<p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%281%29.png"></p>
<blockquote>
<p>首先判断你是左撇子还是右撇子？</p>
<p>如果是右撇子，那么<code>左手指的是天命</code>,<code>右手指的是后天命运</code></p>
<p>如果是左撇子，那么<code>右手指的是天命</code>,<code>左手指的是后天命运</code></p>
</blockquote>
<h1 id="手相主要看哪些？"><a href="#手相主要看哪些？" class="headerlink" title="手相主要看哪些？"></a>手相主要看哪些？</h1><ul>
<li>生命线</li>
<li>智慧线</li>
<li>感情线</li>
<li>命运线</li>
<li>神秘十字线</li>
<li>霸王线</li>
<li>星线</li>
<li>赌博纹</li>
<li>所罗门之星</li>
<li>所罗门之环</li>
<li>千金纹</li>
<li>佛眼</li>
</ul>
<h1 id="生命线"><a href="#生命线" class="headerlink" title="生命线"></a>生命线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%282%29.png"><br>生命线和<code>形状有关，线条弧度</code>有关，最好不要是迅速下降的。<br>生命线越多表示生命力越顽强，注意并不是越长就一定越好。<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%284%29.png"><br>如果越垂直，甚至不过食指和中指中间，表示生命力越弱。<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%283%29.png"><br>生命线末端分叉，叫做<code>旅行线</code>，有旅行线的人有两个好处：<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%285%29.png"></p>
<ol>
<li>表示这个线的人有可能到离家很远的地方生活，但是生活会很好，生命力顽强。</li>
<li>运气比较好、见识多，机会多。</li>
</ol>
<h1 id="智慧线"><a href="#智慧线" class="headerlink" title="智慧线"></a>智慧线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%287%29.png"><br>智慧线体现的是<code>思考方式和脑回路</code>。和智商高低没有关系。<br>智慧线的长度：表示一个人思考问题<code>时间的长短</code>。<br>如果线条比较直：说明这个人比较理性思维。<br>如果线条比较弯：倾向于感性思维。<br>如果线条非常弯：那就是艺术派，思考问题非常理想化。<br>如果末端撇叉：表示这个人非常聪明。<br>如果有多条智慧线：表示这个人可以有多种才能。<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%288%29.png"></p>
<p>另外可以看智慧线和生命线的<code>起点是否连在一起</code><br>连在一起：通情达理<br>不连在一起：比较任性<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%289%29.png"></p>
<h1 id="感情线"><a href="#感情线" class="headerlink" title="感情线"></a>感情线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2810%29.png"><br>感情线主要是看长短，弯曲程度<br>长短定义：食指和中指之间向掌心的直线<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2811%29.png"><br>短：容易大喜大悲，容易上头，易怒，一见钟情，闪婚<br>长：情绪比较稳定<br>平缓：没那么感情用事<br>感情线的尾端角度：<br>快速上扬：比较容易感情化，容易记仇<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2812%29.png"><br>向下弯折：比较冷血，cool，就是感情对你来说没那么重要<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2813%29.png"><br>末端分叉有三叉戟的是<code>幸运女神线</code>，会给周围的人带来幸福<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2814%29.png"></p>
<blockquote>
<p>找对象：最好找感情线差不多的</p>
</blockquote>
<h1 id="命运线"><a href="#命运线" class="headerlink" title="命运线"></a>命运线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2815%29.png"></p>
<p>特别重要的线,不是所有人都有,这条线又叫命运线&#x2F;幸运线&#x2F;成功线&#x2F;事业线<br>如果上下贯穿连续且清晰：事业有成，终身会比较幸运，领袖型,反之辅助型<br>线是从手内往手指方向看的：代表开始与结束的命运<br>只有开始半段的属于早年运气会比较好，早年尽可能的努力<br>只有后半段的属于大器晚成型，后半生的机会会多一些<br>两条线的：人生中会有两个发展方向，两个收入来源<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2816%29.png"><br>分叉越多越倾向于多方向发展的成功<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2817%29.png"><br>末端有三叉戟：说明晚年幸福<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2818%29.png"><br>线是不连续的：说明人生某个阶段，会突然更换职业，改变事业<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2819%29.png"><br>如果线过于混乱全是细碎的小段：说明命运不太稳定，颠沛流离，不知所措的状态，做什么都无法持久<br>线旁边有一些并行的细线：这些线叫做辅助线，会出现贵人，会帮你度过难关<br>辅助线有内外之分：靠近拇指侧（内）的表示贵人是家人，靠近小指侧的表示贵人是外人<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2820%29.png"></p>
<h1 id="神秘十字线"><a href="#神秘十字线" class="headerlink" title="神秘十字线"></a>神秘十字线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2821%29.png"><br>在感情线和智慧线之间。<br>必须是正十字的，是叉不行。<br>有这条线的人，吸引力法则比较有效，想象的事情通常都能实现。<br>会被神秘力量所保护，就算是灾难来了，也有机会存活的。<br>有这条线的人要相信自己的直觉。<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2822%29.png"></p>
<h1 id="断掌"><a href="#断掌" class="headerlink" title="断掌"></a>断掌</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2823%29.png"><br>断掌：智慧线和情感线连在一起<br>强势，独立性很强，事业性很重</p>
<h1 id="霸王线"><a href="#霸王线" class="headerlink" title="霸王线"></a>霸王线</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2824%29.png"><br>霸王线万中无一的手相<br>有这个线就是有钱,适合创业<br>智慧线分支，形成扫帚，或者是爪子形状<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2825%29.png"></p>
<h1 id="星线-幸运圈"><a href="#星线-幸运圈" class="headerlink" title="星线,幸运圈"></a>星线,幸运圈</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2826%29.png"></p>
<p>特殊的手纹<br>在四根手指的下面<br>三条线以及以上组成的星的形状，交叉到一点<br>这个线是变化的，也许有一天就会有，一直有则更好<br>位置不同，意义不同<br>在无名指下：代表财运，有中彩票的命<br>在食指下：说明愿望将要实现<br>在中指下：说明要出名，或恋爱运，结婚运比较好<br>在小指下：说明你的工作学习将有好成绩<br>幸运圈和幸运星作用一样的</p>
<h1 id="赌博纹"><a href="#赌博纹" class="headerlink" title="赌博纹"></a>赌博纹</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2827%29.png"></p>
<p>赌博纹：也叫直觉线<br>在概率上的运气会比较好，抽签，彩票容易中，小奖不断</p>
<p>如果霸王线加上赌博纹那就无敌了<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2828%29.png"></p>
<h1 id="所罗门之星"><a href="#所罗门之星" class="headerlink" title="所罗门之星"></a>所罗门之星</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2829%29.png"><br>最罕见的手相<br>任何位置，有清晰的五角星<br>有改变历史的命运，或者历史上称为知名人士<br><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2830%29.png"></p>
<h1 id="所罗门之环"><a href="#所罗门之环" class="headerlink" title="所罗门之环"></a>所罗门之环</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2831%29.png"><br>在食指下面有一个半圆形的环<br>这种人通常魅力十足有人气的一种手相<br>迈克尔杰克逊就有</p>
<h1 id="千金纹"><a href="#千金纹" class="headerlink" title="千金纹"></a>千金纹</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/Snipaste_2024-04-27_17-11-45.png"><br>所罗门之环和千金纹比较像：<br>相当于大的所罗门之环<br>有千金纹的人容易一夜暴富，扭转乾坤</p>
<h1 id="佛眼"><a href="#佛眼" class="headerlink" title="佛眼"></a>佛眼</h1><p><img src="https://qnocs.funning.top/blog/shouxiang/shouxiang01%20%2832%29.png"><br>和神灵相关的<br>大拇指第一个关节上有一个像眼睛的纹路。<br>神灵保佑,灵感体质,与神灵相通,有灵感、灵性<br>毕加索就有</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>除此之外也要看 手纹、手线、清晰度等</p>
<p>命运是在你手纹里流淌</p>
<p>手掌厚度、柔软度、手指长度<br>手掌厚的：一般性格比较大气<br>越柔软：财运比较好<br>长度主要看：食指和无名指<br>无名指&gt;食指：各方面的能力才能都会强一点<br>无名指&lt;食指：苦命人，不停的工作劳动，才能方面没有，但很努力的这种</p>
<p>手掌的颜色：<br>红润光泽：生命力比较强</p>
<p>手纹是会变的，大概三个月<br>天命手不容易变化， 变化的是后天手。</p>
]]></content>
      <categories>
        <category>手相</category>
      </categories>
      <tags>
        <tag>手相</tag>
        <tag>掌纹</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 核心概念</title>
    <url>/article/112232.html</url>
    <content><![CDATA[<h2 id="elasticsearch-的核心概念"><a href="#elasticsearch-的核心概念" class="headerlink" title="elasticsearch 的核心概念"></a>elasticsearch 的核心概念</h2><blockquote>
<p>Near Realtime（NRT）近实时</p>
</blockquote>
<p>两个意思：</p>
<ul>
<li>从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；</li>
<li>基于es执行搜索和分析可以达到秒级；</li>
</ul>
<blockquote>
<p>Cluster 集群</p>
</blockquote>
<p>包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是 elasticsearch ）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常</p>
<blockquote>
<p>Node 节点</p>
</blockquote>
<p>集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为 “elasticsearch” 的集群，如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成一个 elasticsearch 集群</p>
<blockquote>
<p>Document&amp;field 文档</p>
</blockquote>
<p>es中的最小数据单元，一个 document 可以是一条客户数据，一条商品分类数据，一条订单数据，通常用 JSON 数据结构表示</p>
<p>一个 index 下的 type 中，都可以去存储多个 document。</p>
<p>一个 document 里面有多个 field，每个field就是一个数据字段</p>
<blockquote>
<p>Index 索引</p>
</blockquote>
<p>包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。</p>
<p>一个 index 包含很多 document，一个 index 就代表了一类类似的或者相同的 document。比如说建立一个 product index，商品索引，里面可能就存放了所有的商品数据，所有的商品 document。</p>
<blockquote>
<p>Type 类型</p>
</blockquote>
<p>每个索引里都可以有一个或多个 type，type 是 index 中的一个逻辑数据分类，一个 type 下的 document，都有相同的 field，比如博客系统，有一个索引，可以定义用户数据 type，博客数据 type，评论数据 type。</p>
<p>每一个 type 里面，都会包含一堆 document</p>
<blockquote>
<p>shard 分片(primary shard)</p>
</blockquote>
<p>单台机器无法存储大量数据，es 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储。有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个 shard 都是一个 lucene index。</p>
<blockquote>
<p>replica 复制集&#x2F;副本(replica shard)</p>
</blockquote>
<p>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica副本。replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。</p>
<p>primary shard（建立索引时一次设置，不能修改，默认5个）<br>replica shard（随时修改数量，默认1个）<br>默认每个索引 10 个 shard，5个 primary shard，5个 replica shard，最小的高可用配置，是 2台 服务器。</p>
<h2 id="es核心概念-vs-db核心概念"><a href="#es核心概念-vs-db核心概念" class="headerlink" title="es核心概念 vs db核心概念"></a>es核心概念 vs db核心概念</h2><table>
<thead>
<tr>
<th>elasticsearch</th>
<th>数据库</th>
</tr>
</thead>
<tbody><tr>
<td>Document</td>
<td>行</td>
</tr>
<tr>
<td>Type</td>
<td>表</td>
</tr>
<tr>
<td>Index</td>
<td>库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>中间件</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>核心</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 入门知识</title>
    <url>/article/112211.html</url>
    <content><![CDATA[<h3 id="Elasticsearch-是什么"><a href="#Elasticsearch-是什么" class="headerlink" title="Elasticsearch 是什么"></a>Elasticsearch 是什么</h3><blockquote>
<p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
</blockquote>
<p>以上引用来自于官方，不得不说，解释得蛮文艺的。意料之中和意料之外，这两个词让我想起来了某一年的高考作文题（情理之中和意料之外）。</p>
<p>Elastic Stack 又是什么呢？整个架构图如下图（来源于网络，侵删）所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-04b04318-25c9-4eb5-895e-9c608a4b26f9.jpg"></p>
<p>信息量比较多，对吧？那就记住一句话吧，Elasticsearch 是 Elastic Stack 的核心。</p>
<p>国内外的很多知名公司都在用 Elasticsearch，比如说滴滴、今日头条、谷歌、微软等等。Elasticsearch 有很多强大的功能，比如说全文搜索、购物推荐、附近定位推荐等等。</p>
<p>理论方面的内容就不说太多了，我怕小伙伴们会感到枯燥。毕竟入门嘛，实战才重要。</p>
<h3 id="安装-Elasticsearch"><a href="#安装-Elasticsearch" class="headerlink" title="安装 Elasticsearch"></a>安装 Elasticsearch</h3><p>Elasticsearch 是由 Java 开发的，所以早期的版本需要先在电脑上安装 JDK 进行支持。后来的版本中内置了 Java 环境，所以直接下载就行了。Elasticsearch 针对不同的操作系统有不同的安装包，我们这篇入门的文章就以 Windows 为例吧。</p>
<p>下载地址如下：</p>
<p><a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<p>最新的版本是 7.6.2，280M 左右。但我硬生生花了 10 分钟的时间才下载完毕，不知道是不是连通的 200M 带宽不给力，还是官网本身下载的速度就慢，反正我去洗了 6 颗葡萄吃完后还没下载完。</p>
<p>Elasticsearch 是免安装的，只需要把 zip 包解压就可以了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-07da0521-74eb-4a90-b17f-59258e622609.jpg"></p>
<p>1）bin 目录下是一些脚本文件，包括 Elasticsearch 的启动执行文件。</p>
<p>2）config 目录下是一些配置文件。</p>
<p>3）jdk 目录下是内置的 Java 运行环境。</p>
<p>4）lib 目录下是一些 Java 类库文件。</p>
<p>5）logs 目录下会生成一些日志文件。</p>
<p>6）modules 目录下是一些 Elasticsearch 的模块。</p>
<p>7）plugins 目录下可以放一些 Elasticsearch 的插件。</p>
<p>直接双击 bin 目录下的 elasticsearch.bat 文件就可以启动 Elasticsearch 服务了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-7dd19afd-1aeb-49b6-a07c-f11e139fe3d3.jpg"></p>
<p>输出的日志信息有点多，不用细看，注意看到有“started”的字样就表明启动成功了。为了进一步确认 Elasticsearch 有没有启动成功，可以在浏览器的地址栏里输入 <code>http://localhost:9200</code> 进行查看（9200 是 Elasticsearch 的默认端口号）。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-51f269c2-7482-494a-8a04-6585f20176a7.jpg"></p>
<p>你看，为了 Search。</p>
<p>那如何停止服务呢？可以直接按下 <code>Ctrl+C</code> 组合键——粗暴、壁咚。</p>
<h3 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h3><p>通过 Kibana，我们可以对 Elasticsearch 服务进行可视化操作，就像在 Linux 操作系统下安装一个图形化界面一样。</p>
<p>下载地址如下：</p>
<p><a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p>
<p>最新的版本是 7.6.2，284M 左右，体积和 Elasticsearch 差不多。选择下载 Windows 版，zip 格式的，完成后直接解压就行了。下载的过程中又去洗了 6 颗葡萄吃，狗头。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-12372ee6-acc0-4425-964b-ca32886f17ce.jpg"></p>
<p>包目录不再一一解释了，进入 bin 目录下，双击运行 kibana.bat 文件，启动 Kibana 服务。整个过程比 Elasticsearch 要慢一些，当看到 <code>[Kibana][http] http server running</code> 的信息后，说明服务启动成功了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-784d70ef-b6e7-4312-85f1-36ace9b2a5bd.jpg"></p>
<p>在浏览器地址栏输入 <code>http://localhost:5601</code> 查看 Kibana 的图形化界面。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-e6f64545-a925-4bb4-a25e-44129832fb4e.jpg"></p>
<p>由于当前的 Elasticsearch 服务端中还没有任何数据，所以我们可以选择「Try Our Sample Data」导入 Kibana 提供的模拟数据体验一下。下图是导入电商数据库的看板页面，是不是很丰富？</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-a16d99ff-272d-43bb-aa94-23b240cc464b.jpg"></p>
<p>打开 Dev Tools 面板，可以看到一个简单的 DSL 查询语句（一种完全基于 JSON 的特定于领域的语言），点击「运行」按钮后就可以看到 JSON 格式的数据了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-5c44bd79-d3a9-49fb-9414-04dc38840cfb.jpg"></p>
<h3 id="Elasticsearch-的关键概念"><a href="#Elasticsearch-的关键概念" class="headerlink" title="Elasticsearch 的关键概念"></a>Elasticsearch 的关键概念</h3><p>在进行下一步之前，需要先来理解 Elasticsearch 中的几个关键概念，比如说什么是索引，什么是类型，什么是文档等等。Elasticsearch 既然是一个数据引擎，它里面的一些概念就和 MySQL 有一定的关系。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-ad2b2f8c-5a19-4c5e-9bc7-cf7ba17830bf.jpg"></p>
<p>看完上面这幅图（来源于网络，侵删），是不是瞬间就清晰了。向 Elasticsearch 中存储数据，其实就是向 Elasticsearch 中的 index 下面的 type 中存储 JSON 类型的数据。</p>
<h3 id="在-Java-中使用-Elasticsearch"><a href="#在-Java-中使用-Elasticsearch" class="headerlink" title="在 Java 中使用 Elasticsearch"></a>在 Java 中使用 Elasticsearch</h3><p>有些小伙伴可能会问，“大哥，我是一名 Java 程序员，我该如何在 Java 中使用 Elasticsearch 呢？”这个问题问得好，这就来，这就来。</p>
<p>Elasticsearch 既然内置了 Java 运行环境，自然就提供了一系列 API 供我们操作。</p>
<p>第一步，在项目中添加 Elasticsearch 客户端依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步，新建测试类 ElasticsearchTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;writer&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">                .source(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;火锅&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;age&quot;</span>, <span class="number">18</span>,</span><br><span class="line">                        <span class="string">&quot;memo&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>);</span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;writer&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> getResponse.getSourceAsString();</span><br><span class="line"></span><br><span class="line">        System.out.println(sourceAsString);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）RestHighLevelClient 为 Elasticsearch 提供的 REST 客户端，可以通过 HTTP 的形式连接到 Elasticsearch 服务器，参数为主机名和端口号。</p>
<p>有了 RestHighLevelClient 客户端，我们就可以向 Elasticsearch 服务器端发送请求并获取响应。</p>
<p>2）IndexRequest 用于向 Elasticsearch 服务器端添加一个索引，参数为索引关键字，比如说“writer”，还可以指定 id。通过 source 的方式可以向当前索引中添加文档数据源（键值对的形式）。</p>
<p>有了 IndexRequest 对象后，可以调用客户端的 <code>index()</code> 方法向 Elasticsearch 服务器添加索引。</p>
<p>3）GetRequest 用于向 Elasticsearch 服务器端发送一个 get 请求，参数为索引关键字，以及 id。</p>
<p>有了 GetRequest 对象后，可以调用客户端的 <code>get()</code> 方法向 Elasticsearch 服务器获取索引。<code>getSourceAsString()</code> 用于从响应中获取文档数据源（JSON 字符串的形式）。</p>
<p>好了，来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;火锅&quot;,&quot;age&quot;:18,&quot;memo&quot;:&quot;一枚有趣的程序员&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>完全符合我们的预期，perfect！</p>
<p>也可以通过 Kibana 的 Dev Tools 面板查看“writer”索引，结果如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/elasticsearch/rumen-64baa243-0075-436e-a070-f28813fee284.jpg"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>OSS基本操作</title>
    <url>/article/112218.html</url>
    <content><![CDATA[<h3 id="开通-OSS"><a href="#开通-OSS" class="headerlink" title="开通 OSS"></a>开通 OSS</h3><p>OSS 也就是 Object Storage Service，是阿里云提供的一套对象存储服务，国内的竞品还有七牛云的 Kodo和腾讯云的COS。</p>
<p>第一步，登录阿里云官网，搜索“OSS”关键字，进入 OSS 产品页。</p>
<p>第二步，如果是 OSS 新用户的话，可以享受 6 个月的新人专享优惠价，不过续费的时候还是会肉疼。</p>
<p>第三步，进入 OSS 管理控制台，点击「Bucket 列表」，点击「创建 Bucket」。</p>
<p>Bucket 的词面意思是桶，这里指存储空间，就是用于存储对象的容器。注意读写权限为“公共读”，也就是允许互联网用户访问云空间上的图片。</p>
<p>第四步，点击「确定」就算是开通成功了。</p>
<h3 id="整合-OSS"><a href="#整合-OSS" class="headerlink" title="整合 OSS"></a>整合 OSS</h3><p>第一步，在 pom.xml 文件中添加 OSS 的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阿里云 OSS --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.10.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步，在 application.yml 文件中添加 OSS 配置项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aliyun:</span><br><span class="line">  oss:</span><br><span class="line">      # oss对外服务的访问域名</span><br><span class="line">    endpoint: oss-cn-beijing.aliyuncs.com</span><br><span class="line">      # 访问身份验证中用到用户标识</span><br><span class="line">    accessKeyId: LTAI5</span><br><span class="line">      # 用户用于加密签名字符串和oss用来验证签名字符串的密钥</span><br><span class="line">    accessKeySecret: RYN</span><br><span class="line">      # oss的存储空间</span><br><span class="line">    bucketName: itwanger-oss1</span><br><span class="line">      # 上传文件大小(M)</span><br><span class="line">    maxSize: 3</span><br><span class="line">      # 上传文件夹路径前缀</span><br><span class="line">    dir:</span><br><span class="line">      prefix: codingmore/images/</span><br></pre></td></tr></table></figure>

<p>第三步，新增 OssClientConfig.java 配置类，主要就是通过  @Value 注解从配置文件中获取配置项，然后创建 OSSClient。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssClientConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    String endpoint ;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span></span><br><span class="line">    String accessKeyId ;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span></span><br><span class="line">    String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OSSClient <span class="title function_">createOssClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (OSSClient)<span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步，新增文件上传接口 OssController.java，参数为 MultipartFile。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;上传&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ossController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOssService ossService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/upload&quot;,method=RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;上传&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultObject&lt;String&gt; <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest req)</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultObject.success(ossService.upload(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步，新增 Service，将文件上传到 OSS，并返回文件保存路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IOssService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.maxSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.dir.prefix&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dirPrefix;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> upload(file.getInputStream(), file.getOriginalFilename());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(InputStream inputStream,String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> getBucketName(name);</span><br><span class="line">        <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">        ossClient.putObject(bucketName, objectName, inputStream);</span><br><span class="line">        <span class="keyword">return</span> formatPath(objectName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getBucketName</span><span class="params">(String url)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ext</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String extItem:imageExtension)&#123;</span><br><span class="line">            <span class="keyword">if</span>(url.indexOf(extItem) != -<span class="number">1</span>)&#123;</span><br><span class="line">                ext = extItem;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirPrefix+ DateUtil.today()+<span class="string">&quot;/&quot;</span>+ IdUtil.randomUUID()+ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">formatPath</span><span class="params">(String objectName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://&quot;</span>  +bucketName+<span class="string">&quot;.&quot;</span>+ ossClient.getEndpoint().getHost() + <span class="string">&quot;/&quot;</span> + objectName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="利用-OSS-进行自动转链"><a href="#利用-OSS-进行自动转链" class="headerlink" title="利用 OSS 进行自动转链"></a>利用 OSS 进行自动转链</h3><p>第一步，在 PostsServiceImpl.java 中添加图片转链的方法，主要利用正则表达式找出文章内容中的外链，然后将外链的图片上传到 OSS，然后再替换掉原来的外链图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配图片的 markdown 语法</span></span><br><span class="line"><span class="comment">// ![](hhhx.png)</span></span><br><span class="line"><span class="comment">// ![xx](hhhx.png?ax)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IMG_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;\\!\\[.*\\]\\((.*)\\)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleContentImg</span><span class="params">(Posts posts)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> posts.getPostContent();</span><br><span class="line"></span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(IMG_PATTERN, Pattern.CASE_INSENSITIVE);</span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(content);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Future&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">imageTag</span> <span class="operator">=</span> m.group();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;使用分组进行替换&#123;&#125;&quot;</span>, imageTag);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> imageTag.substring(imageTag.indexOf(<span class="string">&quot;(&quot;</span>) + <span class="number">1</span>, imageTag.indexOf(<span class="string">&quot;)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确认是本站链接，不处理</span></span><br><span class="line">        <span class="keyword">if</span> (imageUrl.indexOf(iOssService.getEndPoint()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过线程池将图片上传到 OSS</span></span><br><span class="line">        Future&lt;String&gt; future = ossUploadImageExecutor.submit(() -&gt; iOssService.upload(imageUrl));</span><br><span class="line">        map.put(imageUrl, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String oldUrl : map.keySet()) &#123;</span><br><span class="line">        Future&lt;String&gt; future = map.get(oldUrl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> future.get();</span><br><span class="line">           content = content.replace(oldUrl, imageUrl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;获取图片链接出错&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    posts.setPostContent(content);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>第二步，在 OssServiceImpl.java 中添加根据外链地址上传图片到 OSS 的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> getFileName(url);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url).openStream()) &#123;</span><br><span class="line">        ossClient.putObject(bucketName, objectName, inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOGGER.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatOSSPath(objectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟带你深入浅出搞懂 Nginx</title>
    <url>/article/112217.html</url>
    <content><![CDATA[<p>作为开发者，相信大家都知道 Nginx 的重要性。Nginx 是一个高性能的 HTTP 和反向代理 Web 服务器，由俄罗斯的伊戈尔·赛索耶夫开发，第一个版本发布于 2004 年 10 月 4 日。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-01.png"></p>
<p>Nginx 的特点是：</p>
<ul>
<li>内存占用少</li>
<li>并发能力强（可支持大约 50000 个并发连接）</li>
<li>配置超简洁</li>
<li>bug 非常少</li>
<li>安装超简单</li>
<li>服务特别稳（几个月也不需要重启）</li>
</ul>
<p>基于这些特点，越来越多的网站开始使用 Nginx。于是，掌握 Nginx 就变成了开发者的一项必不可少的技能。</p>
<h2 id="Nginx-的作用"><a href="#Nginx-的作用" class="headerlink" title="Nginx 的作用"></a>Nginx 的作用</h2><p><strong>反向代理</strong>是 Nginx 作为 Web 服务器最常用的功能之一。什么是反向代理呢？很多初学者在第一次遇到这个名词的时候总免不了出现很多问号。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-02.png"></p>
<p>那要想搞明白什么是反向代理，就必须得搞明白什么是正向代理。</p>
<p>举个例子，小二的浏览器是无法直接访问谷哥的，但香港的代理服务器是可以访问谷哥的，于是小二访问了香港的代理服务器，也就间接地访问了谷哥。那这台代理服务器也就是<strong>正向代理</strong>。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-03.png"></p>
<p>总结一句就是，<strong>正向代理是代理客户端的</strong>，让你能正常访问目的服务器。</p>
<p>与之相反，<strong>反向代理是代理服务器的</strong>，让大量的请求均衡地访问到某一台服务器上。</p>
<p>举个例子，10 万个小二同时在访问 <a href="https://www.itwanger.com/">itwanger.com</a>， 如果只有一台服务器的话，很容易就瘫痪了，于是高并发的情况下会有很多台服务器（假如 10 台吧）来接这个活，那怎么让 10 万个小二访问到这 10 台服务器呢？</p>
<p>这就需要一个反向代理服务器了，反向代理服务器让 1 万个小二访问服务器 A，1 万个小二访问服务器 B，1 个小二访问服务器 C，这样的话，每台服务器的压力就相应减小了，是不是很 nice？</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-04.png"></p>
<p>那问题来了。每台服务器的能力可能不同，比如说服务器 A 的内存比较大一点，有 100 个 G；服务器 B 的内存小一点，有 10 个 G；服务器 C 的内存更小一点，只有 1 个 G。怎么才能让没台服务器承担起它能力范围内的访问呢？</p>
<p><strong>Nginx 内置了轮询和加权轮询来达到负载均衡的目的</strong>。服务器 A 牛逼就把它的权重加大一点，让 5 万个小二访问它；服务器 B 弱一点，权重就再小一点，让 2 万个小二访问它；服务器 C 更弱，权重就最小，让 1 万个小二访问它。</p>
<p>除此之外，Nginx 还有一个很牛逼的功能是<strong>动静分离</strong>。</p>
<p>在我们的软件开发中，有些请求是需要后台处理的；有些请求是不需要后台处理的，比如说 css、js 这些文件请求，这些不需要经过后台处理的文件就叫静态文件。</p>
<p>我们可以根据一些规则，把动态资源和静态资源分开，然后通过 Nginx 把请求分开，静态资源的请求就不需要经过 Web 服务器处理了，从而提高整体上的资源的响应速度。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-05.png"></p>
<h2 id="Nginx-的安装"><a href="#Nginx-的安装" class="headerlink" title="Nginx 的安装"></a>Nginx 的安装</h2><p>针对不同的操作系统，Nginx 的安装各不相同。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 可以直接到官网下载 zip 绿色安装包，解压后就可以了。</p>
<blockquote>
<p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
</blockquote>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>macOS 可以通过 Homebrew 来安装，之前没有安装的话可以戳<a href="https://javabetter.cn/gongju/brew.html">这个链接</a>，终端的话，建议大家使用 <a href="https://javabetter.cn/gongju/warp.html">wrap</a>，有 AI 提示，非常方便。</p>
<p>安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>大体的过程就是，你问一下 wrap，我怎么安装 Nginx 啊，它就会告诉你完整的安装和启动步骤，并且会告诉你 Nginx 的配置文件在哪里。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/nginx-20231209205522.png"></p>
<p>如果端口不是 80 的话，可以在配置文件里进行修改，比如说我改成了 8088。</p>
<p>那安装成功后就可以通过 <code>http://localhost:8088</code> 来访问了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/nginx-20231209205810.png"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux 的安装方式有很多种，每一家的服务器厂商都会有 doc 文档。比如说<a href="https://curl.qcloud.com/gIsvte7E">腾讯云</a>的你搜一下 Nginx 关键字就可以看到了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/nginx-20231209210202.png"></p>
<p>我这里以 macOS 环境为例，来演示一下。</p>
<p>第一步，通过 <code>brew info nginx</code> 命令查看 Nginx 是否安装。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-07.png"></p>
<p>第二步，通过 <code>brew install nginx</code> 命令安装 Nginx。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-08.png"></p>
<p>从以上信息可以得出：</p>
<ul>
<li>根目录是 <code>/usr/local/var/www</code></li>
<li>配置文件是 <code>/usr/local/etc/nginx/nginx.conf</code></li>
<li>默认端口是 8080</li>
</ul>
<p>第三步，通过 <code>nginx</code> 命令启动 Nginx。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-09.png"></p>
<p>第四步，在浏览器地址栏通过 <code>localhost:8080</code> 访问，可以看到以下欢迎页面。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-10.png"></p>
<h2 id="Nginx-常用命令"><a href="#Nginx-常用命令" class="headerlink" title="Nginx 常用命令"></a>Nginx 常用命令</h2><p>通常来说，Nginx 一旦启动后，我们是很少让它退出的，使用最多的就是 reload 命令。当我们修改了配置文件，是需要执行一次 reload 命令让 Nginx 生效的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx  启动</span><br><span class="line">nginx -s stop  停止</span><br><span class="line">nginx -s quit  安全退出</span><br><span class="line">nginx -s reload  重新加载配置文件</span><br><span class="line">nginx -t  检查配置文件是否正确</span><br><span class="line">ps aux|grep nginx  查看nginx进程</span><br></pre></td></tr></table></figure>

<p>重点强调一下 <code>nginx -t</code> 命令，这个命令可以检查配置文件是否正确，如果正确的话，会输出以下信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>假如你忘记配置文件的位置，那这个命令就实在是太有用了。</p>
<p>另外，Nginx 的 reload 对用户是无感的，这一点我觉得很牛逼，你重启了 Nginx，但用户就仿佛没有感觉，还在继续访问网站，这就是 Nginx 的优势。</p>
<h2 id="Nginx-的配置"><a href="#Nginx-的配置" class="headerlink" title="Nginx 的配置"></a>Nginx 的配置</h2><p>我们先来看一下 Nginx 的配置结构图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main        # 全局配置</span><br><span class="line">├── events  # 配置网络连接</span><br><span class="line">├── http    # 配置代理、缓存、日志等</span><br><span class="line">│   ├── upstream # 配置负载均衡</span><br><span class="line">│   ├── server   # 配置虚拟主机，可以有多个 server</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   ├── location  # 用于匹配 URI（URL 是 URI 的一种），可以有多个 location</span><br><span class="line">│   │   ├── location</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>

<p>再把 Nginx 的默认配置拉出来看一下，我把注释加了进去，这样大家很容易就明白这行配置是用来干嘛的了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1; # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types; # 文件扩展名与类型映射表</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on; # 开启高效传输模式</span><br><span class="line">    keepalive_timeout  65; # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080; # 配置监听的端口</span><br><span class="line">        server_name  localhost; # 配置的域名</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # 网站根目录</span><br><span class="line">            index  index.html index.htm; # 默认首页文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html; # 默认50x对应的访问页面</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    include servers/*; # 加载子配置项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们以生产环境 Linux 为例。</p>
<p>由于我的服务器上 80 端口是默认打开的，所以我将监听端口配置成了 80，如果你配置成其他端口的话，记得云服务的安全组里把端口打开。</p>
<p>root 我指定了 <code>/home/www</code> 目录，首页文件为 index.html。这个文件是我自定义的，来看一下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;马斯克&lt;/title&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;niubi.jpeg&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>好，保存配置文件，并且 reload Nginx，我们在本地的浏览器中输入服务器的 IP 地址就可以看到效果了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-12.png"></p>
<h2 id="Nginx-的学习资料"><a href="#Nginx-的学习资料" class="headerlink" title="Nginx 的学习资料"></a>Nginx 的学习资料</h2><p>关于 Nginx 的负载均衡，还有动静分离，我们以后有机会再讲。Nginx 的入门非常简单，但有一说一，如果想要在工作中用好 Nginx，还是需要花费一番功夫的。</p>
<p>我这里再给大家推荐一些不错的学习资料吧。</p>
<p><strong>1）狂神说的视频入门教程</strong>，我个人觉得，狂神的入门教程还是非常舒适的，语速和内容都刚刚好。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-13.png"></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1F5411J7vK">https://www.bilibili.com/video/BV1F5411J7vK</a></p>
</blockquote>
<p><strong>2）黑马程序员Nginx教程</strong>，总共 159 讲，基本上算是非常全面的 Nginx 的视频教程了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-14.png"></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1ov41187bq">https://www.bilibili.com/video/BV1ov41187bq</a></p>
</blockquote>
<p><strong>3）极客时间上的 Nginx100 讲</strong>，讲的比较深一点，涉及到不少原理层面的东西。钱包比较鼓的话，可以去付费下：<a href="http://gk.link/a/12eru">http://gk.link/a/12eru</a></p>
<p><strong>4）Nginx 从入门到实践，万字详解</strong>，图文版的，可以到掘金上看看这篇文章，内容基本上面面俱到了（可以看一下下面的目录），配合前面的视频课，拿下 Nginx 基本上是稳了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nginx/nginx-15.png"></p>
<blockquote>
<p><a href="https://juejin.cn/post/6844904144235413512">https://juejin.cn/post/6844904144235413512</a></p>
</blockquote>
<p>这些资料如果能全部过一遍的话，我要喊你 Nginx 小王子了，估计公司遇到 Nginx 问题的话，你肯定是解决问题的那一个。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper一看一个不吱声</title>
    <url>/article/112221.html</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Apache ZooKeeper 是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。</p>
<p>在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。<br>ZK可以提供诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知，集群管理，Master选举，分布式锁，分布式队列等功能。</p>
<p>「它具有以下特性：」</p>
<ul>
<li>「顺序一致性」：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</li>
<li>「原子性」：要么所有应用，要么不应用；不存在部分机器应用了该事务，而「另一部分没有应用」的情况；</li>
<li>「单一视图」：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；</li>
<li>「可靠性」：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</li>
<li>「实时性」：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（「一段时间」）。</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。</p>
<ul>
<li><p>ZooKeeper的数据模型也具有一个固定的根节点<code>（/）</code>，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。</p>
</li>
<li><p>ZooKeeper 树中的每一层级用斜杠<code>（/）</code>分隔开，且只能用绝对路径（如<code>get /work/task</code>）的方式查询 ZooKeeper 节点，而不能使用相对路径。</p>
</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/shujumoxing-1.png"></p>
<p><strong>「为什么 ZooKeeper 不能采用相对路径查找节点呢？」</strong></p>
<blockquote>
<p>❝</p>
<p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。</p>
<p>❞</p>
</blockquote>
<p>像这种查找与给定值相等的记录问题最适合用散列来解决。</p>
<p>因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 <code>hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes</code>，用节点的完整路径来作为 key 存储节点数据。</p>
<p>这样就大大提高了 ZooKeeper 的性能。</p>
<p><strong>「节点类型」</strong></p>
<p>ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p>
<blockquote>
<p>❝</p>
<p>1、持久节点</p>
<p>❞</p>
</blockquote>
<p>一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p>
<blockquote>
<p>❝</p>
<p>2、临时节点</p>
<p>❞</p>
</blockquote>
<p>如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。</p>
<p>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。</p>
<p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为<code>/servers</code>节点，并为集群下的每台服务器创建一个临时节点<code>/servers/host</code>，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。</p>
<blockquote>
<p>❝</p>
<p>3、有序节点</p>
<p>❞</p>
</blockquote>
<p>节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。</p>
<p>例如一个客户端创建了一个路径为 <code>works/task-</code>的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为<code>works/task-1</code>。</p>
<ul>
<li>通过这种方式我们可以直观的查看到节点的创建顺序。</li>
</ul>
<p>ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组<code>（byte data[]）</code>，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p>
<p><strong>「节点的状态结构」</strong></p>
<p>执行<code>stat /zk_test</code>，可以看到控制台输出了一些信息，这些就是节点状态信息。</p>
<p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：</p>
<table>
<thead>
<tr>
<th><strong>「状态属性」</strong></th>
<th><strong>「说明」</strong></th>
</tr>
</thead>
<tbody><tr>
<td>czxid</td>
<td>数据节点创建时的事务 ID</td>
</tr>
<tr>
<td>ctime</td>
<td>数据节点创建时的时间</td>
</tr>
<tr>
<td>mzxid</td>
<td>数据节点最后一次更新时的事务 ID</td>
</tr>
<tr>
<td>mtime</td>
<td>数据节点最后一次更新时的时间</td>
</tr>
<tr>
<td>pzxid</td>
<td>数据节点的子节点最后一次被修改时的事务 ID</td>
</tr>
<tr>
<td><strong>「cversion」</strong></td>
<td><strong>「子节点的版本」</strong></td>
</tr>
<tr>
<td><strong>「version」</strong></td>
<td><strong>「当前节点数据的版本」</strong></td>
</tr>
<tr>
<td><strong>「aversion」</strong></td>
<td><strong>「节点的 ACL 的版本」</strong></td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据内容的长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>数据节点当前的子节点个数</td>
</tr>
</tbody></table>
<p><strong>「数据节点的版本」</strong></p>
<p>在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p>
<p>ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。</p>
<p>事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。</p>
<p>事务快照则是将内存数据持久化到本地磁盘。</p>
<p>❝<br>这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。<br>❞<br>在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p>
<p>「内存数据」</p>
<p>ZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。</p>
<p>从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。</p>
<p>我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。</p>
<p>而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。<br>DataTree 类定义了一个 ZooKeeper 数据的内存结构。</p>
<p>DataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。</p>
<p>可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。</p>
<p>「事务日志」</p>
<p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。</p>
<p>❝<br>而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。<br>❞<br>在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。</p>
<h2 id="Watch机制"><a href="#Watch机制" class="headerlink" title="Watch机制"></a>Watch机制</h2><p>ZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；</p>
<p><strong>「如何实现：」</strong></p>
<p>我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure>

<p>上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：</p>
<ul>
<li><p>connectString 服务端地址</p>
</li>
<li><p>sessionTimeout：超时时间</p>
</li>
<li><p>Watcher：监控事件</p>
</li>
</ul>
<p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。</p>
<p>除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getData(String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure>

<p>触发通知的条件：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/watch-1.png"></p>
<p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。</p>
<ul>
<li>例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。</li>
</ul>
<p><strong>「当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？」</strong></p>
<p>答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。</p>
<p><strong>「订阅发布场景实现」</strong></p>
<blockquote>
<p>❝</p>
<p>提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。</p>
<p>❞</p>
</blockquote>
<p>发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。</p>
<p>一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。</p>
<p>ZooKeeper 采用了两种模式结合的方式实现订阅发布功能。</p>
<blockquote>
<p>❝</p>
<p>下面我们来分析一个具体案例：</p>
<p>❞</p>
</blockquote>
<p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。</p>
<p>通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。</p>
<p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。</p>
<p>如<code>/confs/data_item1</code>。</p>
<ul>
<li><p>服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。</p>
</li>
<li><p>而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p>
</li>
</ul>
<p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。</p>
<blockquote>
<p>❝</p>
<p>要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。</p>
<p>❞</p>
</blockquote>
<h2 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a>会话机制</h2><p>ZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。</p>
<p>而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。</p>
<blockquote>
<p>❝</p>
<p>在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。</p>
<p>❞</p>
</blockquote>
<p>这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）</p>
<ul>
<li><p>会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。</p>
</li>
<li><p>会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。</p>
</li>
<li><p>会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。</p>
</li>
</ul>
<p><strong>「会话状态」</strong></p>
<p>在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。</p>
<p>这些状态包括：</p>
<blockquote>
<p>❝</p>
<p>正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。</p>
<p>❞</p>
</blockquote>
<p>当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。</p>
<p>如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。</p>
<blockquote>
<p>❝</p>
<p>在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。</p>
<p>❞</p>
</blockquote>
<p>最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。</p>
<p><strong>「会话异常」</strong></p>
<p>在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。</p>
<ul>
<li>在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。</li>
</ul>
<p>而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。</p>
<ul>
<li>这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。</li>
</ul>
<p>ZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。</p>
<p>如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。</p>
<p><strong>「分桶策略」</strong></p>
<p>我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。</p>
<ul>
<li>而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。</li>
</ul>
<p>ZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。</p>
<ul>
<li>所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。</li>
</ul>
<blockquote>
<p>❝</p>
<p>ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。</p>
<p>❞</p>
</blockquote>
<p>在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。</p>
<p>这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。</p>
<p><strong>「ZooKeeper 这种会话管理的好处？」</strong></p>
<p>ZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。</p>
<p>而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。</p>
<p>在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。</p>
<p><strong>「底层实现」</strong></p>
<p>ZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。</p>
<ul>
<li>可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。</li>
</ul>
<p><strong>「一个会话过期队列是由若干个 bucket 组成的。」</strong></p>
<ul>
<li><p>bucket 是一个按照时间划分的区间。</p>
</li>
<li><p>在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。</p>
</li>
<li><p>在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。</p>
</li>
<li><p>每个 bucket 中存放了在某一时间内过期的会话。</p>
</li>
</ul>
<p>将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/huihuajizhi-1.png"></p>
<p>首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。</p>
<h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><p>ZooKeeper的ACL可针对znodes设置相应的权限信息。</p>
<p>一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。</p>
<p>最终组成一条例如scheme:id:permission格式的 ACL 请求信息。<br>「权限模式：Scheme」</p>
<p>ZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。</p>
<p>❝<br>范围验证<br>❞<br>所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。</p>
<p>比如我们可以让一个 IP 地址为ip：192.168.0.11的机器对服务器上的某个数据节点具有写入的权限。</p>
<p>或者也可以通过ip:192.168.0.11&#x2F;22给一段 IP 地址的机器赋权。</p>
<p>❝<br>口令验证<br>❞<br>可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p>
<p>在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送username:password这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。</p>
<p>❝<br>Super 权限模式<br>❞<br>权限模式 Super 可以认为是一种特殊的 Digest 认证。</p>
<p>具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p>
<p>下面这段代码给出了 Digest 模式下客户端的调用方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建节点</span><br><span class="line">create /digest_node1</span><br><span class="line">//设置digest权限验证</span><br><span class="line">setAcl /digest_node1 digest:用户名:base64格式密码:rwadc </span><br><span class="line">//查询节点Acl权限</span><br><span class="line">getAcl /digest_node1 </span><br><span class="line">//授权操作</span><br><span class="line">addauth digest user:passwd</span><br></pre></td></tr></table></figure>

<p>❝<br>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。<br>❞<br>对其创建的节点要想进行修改应该怎么做呢？</p>
<p>我们可以通过「super 模式」即超级管理员的方式删除该节点或变更该节点的权限验证方式。</p>
<p>正因为「super 模式」有如此大的权限，我们在平时使用时也应该更加谨慎。</p>
<p>❝<br>world 模式<br>❞<br>这种授权模式对应于系统中的所有用户，本质上起不到任何作用。</p>
<p>设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。</p>
<p>「授权对象（ID）」</p>
<p>所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。</p>
<p>如果是 World 模式，是授权系统中所有的用户。</p>
<p>「权限信息（Permission）」</p>
<p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p>
<ul>
<li><p>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</p>
</li>
<li><p>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</p>
</li>
<li><p>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</p>
</li>
<li><p>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</p>
</li>
<li><p>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</p>
</li>
</ul>
<p>❝<br>需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。<br>❞<br>「实现自己的权限口控制」</p>
<p>虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p>
<p>官方文档中对这种机制的定义是 Pluggable ZooKeeper Authenication，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？</p>
<p>❝<br>要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。<br>❞<br>实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？</p>
<p>接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。</p>
<p>第一种是通过设置系统属性来注册自定义的权限控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dzookeeper.authProvider.x=CustomAuthenticationProvider</span><br></pre></td></tr></table></figure>


<p>另一种是在配置文件zoo.cfg中进行配置：</p>
<p><code>authProvider.x=CustomAuthenticationProvider</code></p>
<p>「实现原理」</p>
<p>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</p>
<p>在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。</p>
<p>下次连接服务器后，需要重新调用授权接口进行授权。</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。</p>
<p>❝<br>ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。<br>❞<br>虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。</p>
<p>之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。</p>
<p>「如何 使用 Jute 实现序列化」</p>
<p>如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。</p>
<p>❝<br>下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：<br>❞<br>首先，我们定义了一个test_jute类，为了能够对它进行序列化，需要该test_jute类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class test_jute implements Record&#123;</span><br><span class="line">  private long ids；</span><br><span class="line">  private String name;</span><br><span class="line">  ...</span><br><span class="line">  public void serialize(OutpurArchive a_,String tag)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  public void deserialize(INputArchive a_,String tag)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void serialize(OutpurArchive a_,String tag) throws ...&#123;</span><br><span class="line">  a_.startRecord(this.tag);</span><br><span class="line">  a_.writeLong(ids,&quot;ids&quot;);</span><br><span class="line">  a_.writeString(type,&quot;name&quot;);</span><br><span class="line">  a_.endRecord(this,tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void deserialize(INputArchive a_,String tag) throws &#123;</span><br><span class="line">  a_.startRecord(tag);</span><br><span class="line">  ids = a_.readLong(&quot;ids&quot;);</span><br><span class="line">  name = a_.readString(&quot;name&quot;);</span><br><span class="line">  a_.endRecord(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。</p>
<p>本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte&#x2F;Buffer 类型。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>「ZooKeeper集群模式的特点」</p>
<p>在 ZooKeeper 集群中将服务器分成 「Leader 、Follow 、Observer 三」种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p>
<p>Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。</p>
<p>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。</p>
<p>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。</p>
<p>在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。</p>
<p>❝<br>对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。<br>所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。<br>❞<br>Leader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。</p>
<p>❝<br>在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？<br>❞<br>在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。</p>
<p>ZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。</p>
<p>在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。</p>
<p>分析出该条消息所包含的原始客户端会话请求。</p>
<p>之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。</p>
<p>如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。</p>
<p>当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。</p>
<p>❝<br>如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。<br>❞<br>在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。</p>
<p>❝<br>ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。<br>❞<br>这也是 ZooKeeper 设计的一个缺点。</p>
<p>「Leader选举」</p>
<p>Leader 服务器的选举操作主要发生在两种情况下。</p>
<p>第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。</p>
<p>❝<br>ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。<br>❞<br>❝<br>服务器状态<br>❞<br>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<p>「LOOKING」：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</p>
<p>「FOLLOWING」：跟随者状态。表明当前服务器角色是Follower。</p>
<p>「LEADING」：领导者状态。表明当前服务器角色是Leader。</p>
<p>「OBSERVING」：观察者状态。表明当前服务器角色是Observer。</p>
<p>「事务ID（zxid）」</p>
<p>Zookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。</p>
<p>❝<br>写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。<br>❞<br>ZXID由Leader统一分配，全局唯一，长度64位，递增。</p>
<p>ZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。</p>
<p>「选举过程」</p>
<p>在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。</p>
<p>❝<br>Leader 失效发现<br>❞<br>在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。</p>
<p>在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。<br>首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。</p>
<p>❝<br>Leader重新选举<br>❞<br>当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。</p>
<p>ZooKeeper 会重新选举出 Leader 服务器。</p>
<p>❝<br>Follow 角色变更<br>❞<br>在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。</p>
<p>❝<br>集群同步数据<br>❞<br>在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。</p>
<p>为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。</p>
<p>「底层实现」</p>
<p>首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。</p>
<p>之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 「FastLeaderElection」 类实现的。<br>该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。</p>
<p>FastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。</p>
<p>而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。<br>在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。</p>
<p>❝<br>这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。<br>❞<br>因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。</p>
<p>「Observer」</p>
<p>在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。</p>
<p>但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。<br>在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。</p>
<p>不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：</p>
<p>随着集群规模的变大，集群处理写入的性能反而下降。</p>
<p>ZooKeeper 集群无法做到跨域部署。</p>
<p>其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。</p>
<p>这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。</p>
<p>正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。</p>
<p>为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。<br>Observer 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。</p>
<p>这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。</p>
<p>在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。<br>因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。</p>
<p>「在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？」</p>
<p>两个原因：</p>
<p>❝<br>在容错能力相同的情况下，奇数台更节省资源<br>❞<br>Zookeeper中 Leader 选举算法采用了Zab协议。</p>
<p>Zab核心思想是当多数 Server 写成功，则写成功。</p>
<p>举两个例子：</p>
<p>假如zookeeper集群1 ，有3个节点，3&#x2F;2&#x3D;1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。</p>
<p>假如zookeeper集群2，有4个节点，4&#x2F;2&#x3D;2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。</p>
<p>集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。</p>
<p>❝<br>防止由脑裂造成的集群不可用。<br>❞<br>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p>
<p>下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：</p>
<p>假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群：</p>
<p>A ：1个节点 ，B ：4个节点</p>
<p>A ：2个节点， B ：3个节点</p>
<p>可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 &gt; 总节点数量&#x2F;2 。</p>
<p>所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。</p>
<p>假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：</p>
<p>A：1个节点 ，  B：3个节点</p>
<p>A：2个节点 ， B：2个节点</p>
<p>因为A和B都是2个节点，都不满足 可用节点数量 &gt; 总节点数量&#x2F;2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。</p>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p><strong>「ZAB 协议算法」</strong></p>
<p>ZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。</p>
<blockquote>
<p>❝</p>
<p>为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。</p>
<p>❞</p>
</blockquote>
<p>ZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。</p>
<ul>
<li>在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。</li>
</ul>
<p>当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p>
<blockquote>
<p>❝</p>
<p>以 ZooKeeper 集群为例，这个操作过程可以概括为：</p>
<p>❞</p>
</blockquote>
<p>当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。</p>
<p>当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。</p>
<p>然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。</p>
<p><strong>「崩溃恢复」</strong></p>
<p>当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。</p>
<blockquote>
<p>❝</p>
<p>因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。</p>
<p>❞</p>
</blockquote>
<p>崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。</p>
<blockquote>
<p>❝</p>
<p>投票过程如下：</p>
<p>❞</p>
</blockquote>
<p>当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。</p>
<p>在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。</p>
<blockquote>
<p>❝</p>
<p>选票结构：</p>
<p>❞</p>
</blockquote>
<p>以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/zab-1.png"></p>
<ul>
<li><p>logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。</p>
</li>
<li><p>state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。</p>
</li>
<li><p><code>self_id</code>：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。</p>
</li>
<li><p><code>self_zxid</code>：当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>
</li>
<li><p><code>vote_id</code>：投票要被推举的服务器的唯一 ID 。</p>
</li>
<li><p><code>vote_zxid</code>：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>
</li>
</ul>
<p>当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。</p>
<blockquote>
<p>❝</p>
<p>选票筛选</p>
<p>❞</p>
</blockquote>
<p>当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。</p>
<p>Follow 服务器进行选票对比的过程，如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/zab-2.png"></p>
<p>首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。</p>
<p>接下来再对比<code>vote_zxid</code>被选举的服务器 ID 信息，若接收到的外部投票信息中的 <code>vote_zxid</code>字段较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code>vote_myid</code>，并广播出去。</p>
<p>要是对比的结果相同，则继续对比<code>vote_myid</code>被选举服务器上所保存的最大事务 ID ，若外部投票的<code>vote_myid</code> 比较大，则将自己的票中的 <code>vote_myid</code>更新为收到的票中的<code>vote_myid</code> 。</p>
<p>经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。</p>
<p><strong>「消息广播」</strong></p>
<p>在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。</p>
<p>ZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/zab-3.png"></p>
<p>当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。</p>
<p>当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。</p>
<p>这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。</p>
<h2 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h2><p>「日志类型」</p>
<p>在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。</p>
<p>❝<br>其中，数据日志是我们在生产环境中需要定期维护和管理的文件。<br>❞<br>「清理方案」</p>
<p>如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。</p>
<p>备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。</p>
<p>「清理工具」</p>
<p>❝<br>Corntab<br>❞<br>首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。</p>
<p>crontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。</p>
<p>❝<br>PurgeTxnLog<br>❞<br>ZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。</p>
<p>PurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。</p>
<p>如下面的代码所示，首先，我们在&#x2F;usr&#x2F;bin目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。</p>
<p>在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh  </span><br><span class="line">java -cp &quot;$CLASSPATH&quot; org.apache.zookeeper.server.PurgeTxnLog </span><br><span class="line">echo &quot;清理完成&quot; </span><br></pre></td></tr></table></figure>
<p>PurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。</p>
<h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><p>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>
<blockquote>
<p>❝</p>
<p>实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案</p>
<p>❞</p>
</blockquote>
<p><strong>「方案一：」</strong></p>
<p>使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识</p>
<p><strong>「方案二：」</strong></p>
<p>使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/fenbushisuo-1.png"></p>
<p><strong>「死锁风险:」</strong></p>
<p>两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁</p>
<ul>
<li><p>方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行</p>
</li>
<li><p>方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的</p>
</li>
</ul>
<p><strong>「避免羊群效应」</strong></p>
<p>把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。</p>
<p>如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p>
<blockquote>
<p>❝</p>
<p>为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。</p>
<p>❞</p>
</blockquote>
<p>每次锁被释放，只会有一个锁请求者 会被通知到。</p>
<p>这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/fenbushisuo-2.png"></p>
<p><strong>「用 ZooKeeper 实现分布式锁的算法流程，根节点为 &#x2F;lock：」</strong></p>
<ul>
<li><p>客户端连接 ZooKeeper，并<code>在/lock</code>下创建临时有序子节点，第一个客户端对应的子节点为<code>/lock/lock01/00000001</code>，第二个为 <code>/lock/lock01/00000002</code>；</p>
</li>
<li><p>其他客户端获取<code>/lock01</code>下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</p>
</li>
<li><p>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听<code>/lock01</code>的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</p>
</li>
<li><p>完成业务流程后，删除对应的子节点，释放分布式锁；</p>
</li>
</ul>
<p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p>
<h2 id="实现分布式ID"><a href="#实现分布式ID" class="headerlink" title="实现分布式ID"></a>实现分布式ID</h2><p>我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。</p>
<p>❝<br>每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。<br>❞<br>客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。</p>
<p>「实现原理：」</p>
<p>可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。</p>
<p>客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。</p>
<p>客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</p>
<p>利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。</p>
<p>❝<br>虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。<br>❞<br>其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。</p>
<p>很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。</p>
<h2 id="实现负载均衡"><a href="#实现负载均衡" class="headerlink" title="实现负载均衡"></a>实现负载均衡</h2><p><strong>「常见负载均衡算法」</strong></p>
<blockquote>
<p>❝</p>
<p>轮询法</p>
<p>❞</p>
</blockquote>
<p>轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。</p>
<p>比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。</p>
<blockquote>
<p>❝</p>
<p>随机法</p>
<p>❞</p>
</blockquote>
<p>随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。</p>
<p>不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。</p>
<blockquote>
<p>❝</p>
<p>原地址哈希法</p>
<p>❞</p>
</blockquote>
<p>原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。</p>
<p>采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。</p>
<blockquote>
<p>❝</p>
<p>加权轮询法</p>
<p>❞</p>
</blockquote>
<p>加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。</p>
<blockquote>
<p>❝</p>
<p>加权随机法</p>
<p>❞</p>
</blockquote>
<p>加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。</p>
<blockquote>
<p>❝</p>
<p>最小连接数法</p>
<p>❞</p>
</blockquote>
<p>最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。</p>
<p>一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。</p>
<p><strong>「利用 ZooKeeper 实现 负载均衡 算法」</strong></p>
<blockquote>
<p>❝</p>
<p>这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。</p>
<p>❞</p>
</blockquote>
<p>如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。</p>
<p>在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/fuzaijunheng-1.png"></p>
<p>整个实现的过程如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/fuzaijunheng-2.png"></p>
<ul>
<li><p>首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。</p>
</li>
<li><p>通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。</p>
</li>
<li><p>最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。</p>
</li>
<li><p>我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。</p>
</li>
<li><p>我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。</p>
</li>
<li><p>当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。</p>
</li>
<li><p>具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。</p>
</li>
</ul>
<p><strong>「这里注意：」</strong></p>
<p>我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。</p>
<blockquote>
<p>❝</p>
<p>而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。</p>
<p>❞</p>
</blockquote>
<p>在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。</p>
<h2 id="开源框架使用案例"><a href="#开源框架使用案例" class="headerlink" title="开源框架使用案例"></a>开源框架使用案例</h2><p><strong>「Dubbo与ZooKeeper」</strong></p>
<p>Dubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。</p>
<p><strong>「用ZooKeeper做注册中心」</strong></p>
<p>在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。</p>
<p>而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。</p>
<p>如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 <code>/dubbo/com.foo.BarService/providers</code>目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。</p>
<p>服务消费者在启动时订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址，并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录写入自己的 URL 地址。</p>
<p>该操作是通过 ZooKeeper 服务器在 &#x2F;consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 &#x2F;providers 节点的 watch 监控</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/shiyonganli-1.png"></p>
<p><strong>「Kafka与ZooKeeper」</strong></p>
<p><strong>「Zookeeper的作用」</strong></p>
<p>由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。</p>
<p>为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。</p>
<p>在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。</p>
<p>而在 Kafka 集群中，每台 Broker 服务器又相对独立。</p>
<p>为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 <code>/brokers/topics/[topic]</code> 的形式存在。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/zookeeper/shiyonganli-2.png"></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT-4 trained on YouTube transcripts GPT-4 在 YouTube 记录上进行训练</title>
    <url>/article/112242.html</url>
    <content><![CDATA[<h1 id="GPT-4-trained-on-YouTube-transcripts-GPT-4-在-YouTube-成绩单上进行训练"><a href="#GPT-4-trained-on-YouTube-transcripts-GPT-4-在-YouTube-成绩单上进行训练" class="headerlink" title="GPT-4 trained on YouTube transcripts GPT-4 在 YouTube 成绩单上进行训练"></a>GPT-4 trained on YouTube transcripts GPT-4 在 YouTube 成绩单上进行训练</h1><p>Based on the information provided in the search results, OpenAI reportedly used transcriptions of over a million hours<br>of YouTube videos to train GPT-4, its most advanced large language model. This was part of their effort to gather<br>high-quality training data, which is crucial for the development and improvement of AI models like GPT-4. The company<br>developed its Whisper audio transcription model to assist in this process, which allowed them to transcribe the YouTube<br>content.<br>据报道，根据搜索结果中提供的信息，OpenAI 使用了超过 100 万小时的 <code>YouTube</code> 视频转录来训练其最先进的大型语言模型<br>GPT-4。这是他们收集高质量训练数据的努力的一部分，这对于 GPT-4 等人工智能模型的开发和改进至关重要。该公司开发了 Whisper<br>音频转录模型来协助这一过程，这使他们能够转录 YouTube 内容。</p>
<p>The use of YouTube videos for training data was considered legally questionable by OpenAI, but they believed it to be<br>fair use. OpenAI president Greg Brockman was personally involved in collecting videos that were used for this purpose.<br>The company’s spokesperson, Lindsay Held, stated that OpenAI curates unique datasets for each of its models to help<br>their understanding of the world and uses numerous sources, including publicly available data and partnerships for<br>non-public data.<br>OpenAI 认为使用 YouTube 视频作为训练数据<code>存在法律问题</code>，但他们认为这是合理使用。 OpenAI 总裁 Greg Brockman<br>亲自参与收集用于此目的的视频。该公司发言人 Lindsay Held 表示，OpenAI<br>为其每个模型策划了独特的数据集，以帮助他们了解世界，并使用众多来源，包括公开数据和非公开数据的合作伙伴关系。</p>
<p>Google, which owns YouTube, has ‘robots.txt files and Terms of Service that prohibit unauthorized scraping or<br>downloading of YouTube content. Google spokesperson Matt Bryant mentioned that the company takes technical and legal<br>measures to prevent such unauthorized use when they have a clear legal or policy basis to do so.<br>拥有 YouTube 的 Google 拥有“robots.txt”文件和服务条款，禁止未经授权抓取或下载 YouTube 内容。 Google 发言人 Matt Bryant<br>提到，公司会在有明确的法律或政策依据的情况下，采取技术和法律措施来防止此类未经授权的使用。</p>
<p>The search results indicate that the training of GPT-4 on YouTube transcripts was part of a broader strategy by AI<br>companies to overcome the challenge of finding sufficient and diverse data to train their models effectively. This<br>strategy also included using data from other sources such as Github, chess move databases, and schoolwork content from<br>Quizlet.<br>搜索结果表明，在 YouTube 成绩单上训练 GPT-4 是人工智能公司更广泛战略的一部分，该战略旨在克服寻找充足且多样化的数据来有效训练其模型的挑战。该策略还包括使用来自其他来源的数据，例如<br>Github、国际象棋走棋数据库以及 Quizlet中的作业内容。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>news</category>
        <category>最新AI新闻</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>2026 AI data drought 2026年AI数据干旱</title>
    <url>/article/112241.html</url>
    <content><![CDATA[<h1 id="2026年AI数据干旱"><a href="#2026年AI数据干旱" class="headerlink" title="2026年AI数据干旱"></a>2026年AI数据干旱</h1><p>The potential for a data drought in 2026 is a significant concern for the artificial intelligence (AI) industry, as<br>highlighted by various sources. This situation arises from the rapid consumption of high-quality language data by AI<br>systems, such as ChatGPT, which are trained on extensive datasets compiled from the internet. The demand for this data<br>is outpacing the rate at which it is being produced, leading to predictions that the stock of language data suitable for<br>training AI could be exhausted by 2026</p>
<p>正如各种消息来源所强调的那样，2026 年数据干旱的可能性是人工智能 （AI） 行业的一个重大问题。这种情况源于 ChatGPT<br>等人工智能系统对高质量语言数据的快速消耗，这些系统是在从互联网上编译的广泛数据集上训练的。对这些数据的需求超过了它的产生速度，导致预测适合训练人工智能的语言数据存量可能会在<br>2026 年耗尽</p>
<p>The Epoch AI research group has predicted that we might run out of high-quality data for AI training by 2026, which<br>could significantly slow down future AI development This shortage is attributed to the increasing sophistication of AI<br>programs, which require larger and more complex<br>datasets for training. The Conversation and other sources have echoed these concerns, estimating that low-quality<br>language data will be exhausted between 2030 and 2050, and low-quality image data between 2030 and 2060 This could not<br>only hamper the development of AI but also affect its integration into various devices and programs,<br>potentially transforming lives worldwide</p>
<p>大纪元人工智能研究小组预测，到 2026 年，我们可能会用完用于 AI 训练的高质量数据，这可能会大大减缓未来的 AI<br>发展。这种短缺归因于人工智能程序的日益复杂，需要更大、更复杂的数据集进行训练。《对话》和其他消息来源回应了这些担忧，估计低质量的语言数据将在<br>2030 年至 2050 年之间耗尽，低质量的图像数据将在 2030 年至 2060 年之间耗尽。这不仅会阻碍人工智能的发展，还会影响其与各种设备和程序的集成，从而可能改变全球的生活。</p>
<p>To address this impending shortage, researchers and companies are exploring various strategies. One approach involves<br>improving algorithms to use existing data more efficiently Another potential solution is the generation of synthetic<br>data, which can be curated to suit particular AI models,<br>thus alleviating the reliance on natural data sources Additionally, there’s a push towards federated data sharing as a<br>means to mitigate the lack of available data</p>
<p>为了解决这种迫在眉睫的短缺问题，研究人员和公司正在探索各种策略。一种方法涉及改进算法以更有效地使用现有数据另一个潜在的解决方案是生成合成数据，可以对其进行策划以适应特定的人工智能模型，从而减轻对自然数据源的依赖。此外，还有一种推动联合数据共享的手段，以缓解可用数据的缺乏</p>
<p>The scarcity of natural data sources is compounded by privacy and ethical concerns, as well as the potential for AI<br>systems to develop biased algorithms due to the lack of diverse and inclusive datasets This situation underscores the<br>need for the AI industry to find innovative solutions to the data scarcity problem, such as generating synthetic data or<br>adopting new data generation techniques</p>
<p>隐私和道德问题加剧了自然数据源的稀缺性，以及由于缺乏多样化和包容性数据集，人工智能系统有可能开发有偏见的算法<br>这种情况凸显了人工智能行业需要为数据稀缺问题找到创新的解决方案，例如生成合成数据或采用新的数据生成技术</p>
<p>In summary, the AI industry faces a critical challenge due to the potential shortage of training data by 2026. This<br>situation necessitates a multifaceted approach, including the development of more efficient algorithms, the generation<br>of synthetic data, and the exploration of new sources of training data. Addressing these challenges is crucial for the<br>continued growth and development of AI technologies.<br>总之，由于到 2026 年训练数据可能短缺，人工智能行业面临着严峻的挑战。这种情况需要采取多方面的方法，包括开发更有效的算法、生成合成数据以及探索新的训练数据来源。应对这些挑战对于人工智能技术的持续增长和发展至关重要。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>news</category>
        <category>最新AI新闻</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>Cheap AI data poisoning 廉价AI数据中毒</title>
    <url>/article/112238.html</url>
    <content><![CDATA[<p>Data poisoning is a cybersecurity threat that targets the integrity of machine learning (ML) and artificial intelligence (AI) systems by deliberately manipulating the data used to train these models. This manipulation can lead to incorrect or biased outcomes from AI systems, making data poisoning a significant concern for the reliability and security of AI applications. The concept of data poisoning is not new, but its implications are becoming increasingly critical as AI and ML technologies become more embedded in various aspects of society, including security systems, financial services, healthcare, and autonomous vehicles.</p>
<p>数据中毒是一种<code>网络安全威胁</code>，它通过故意操纵用于训练这些模型的数据来攻击机器学习（ML）和人工智能（AI）系统的完整性。这种操纵可能导致人工智能系统产生不正确或有偏见的结果，使数据中毒成为人工智能应用程序可靠性和安全性的重要问题。数据中毒的概念并不新鲜，但随着人工智能和机器学习技术越来越多地嵌入到社会的各个方面，包括安全系统、金融服务、医疗保健和自动驾驶汽车，其影响变得越来越重要。</p>
<p>Data poisoning attacks can be categorized based on the attacker’s knowledge and the tactics employed. Attacks can range from black-box attacks, where the attacker has no knowledge of the model’s internals, to white-box attacks, where the attacker has full knowledge of the model and its training parameters. The tactics for data poisoning include availability attacks, targeted attacks, subpopulation attacks, and backdoor attacks, each with its own method of corrupting the AI model to achieve different malicious objectives</p>
<p>数据中毒攻击可以根据攻击者的知识和所采用的策略进行分类。攻击的范围可以从黑盒攻击（攻击者不知道模型的内部结构）到白盒攻击（攻击者完全知道模型及其训练参数）。数据中毒的策略包括可用性攻击、有针对性的攻击、子种群攻击和后门攻击，每种攻击都有自己的方法来破坏AI模型，以实现不同的恶意目标。</p>
<p>The methods for carrying out data poisoning attacks can be surprisingly cheap and accessible. For instance, researchers have demonstrated that for as little as $60, a malicious actor could tamper with the datasets that generative AI tools rely on. This could involve purchasing expired domains and populating them with manipulated data, which AI models might then scrape and incorporate into their training datasets. Such attacks could control and poison at least 0.01% of a dataset, which, although it seems small, can be significant enough to cause noticeable distortions in the AI’s outputs</p>
<p>进行数据中毒攻击的方法可以令人惊讶地便宜和容易获得。例如，研究人员已经证明，只需60美元，恶意行为者就可以篡改生成AI工具所依赖的数据集。这可能涉及购买过期的域名并使用操纵的数据填充它们，然后AI模型可以将其抓取并合并到其训练数据集中。这种攻击可以控制和毒害至少0.01%的数据集，虽然看起来很小，但足以导致AI输出的明显失真。</p>
<p>Preventing data poisoning attacks is crucial, especially as more organizations and government agencies rely on AI to deliver essential services. Proactive measures include being diligent about the databases used for training AI models, employing high-speed verifiers, and using statistical methods to detect anomalies in the data. Continuous monitoring of model performance is also essential to detect unexpected shifts in accuracy that could indicate a data poisoning attack</p>
<p>防止数据中毒攻击至关重要，特别是随着越来越多的组织和政府机构依赖人工智能提供基本服务。积极的措施包括对用于训练AI模型的数据库进行认真的研究，使用高速验证器，以及使用统计方法来检测数据中的异常。对模型性能的持续监控对于检测可能表明数据中毒攻击的意外准确性变化也至关重要。</p>
<p>The rise of data poisoning as a threat to AI systems underscores the need for robust security measures and ethical considerations in the development and deployment of AI technologies. As AI becomes more integrated into critical systems, the potential for harm from data poisoning attacks grows, making it imperative for researchers, developers, and policymakers to address this challenge proactively</p>
<p>数据中毒作为对人工智能系统的威胁的兴起，凸显了在人工智能技术的开发和部署中需要强大的安全措施和道德考虑。随着人工智能越来越多地集成到关键系统中，数据中毒攻击造成危害的可能性越来越大，研究人员、开发人员和政策制定者必须积极应对这一挑战。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>news</category>
        <category>最新AI新闻</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>一键部署SpringBoot到远程Docker容器</title>
    <url>/article/112210.html</url>
    <content><![CDATA[<h3 id="关于-Docker"><a href="#关于-Docker" class="headerlink" title="关于 Docker"></a>关于 Docker</h3><p>Docker 是用 go 语言编写的，这也是 go 语言近些年越来越火的原因之一。关于 Docker，有 3 个重要的概念需要了解下：</p>
<ul>
<li>image：镜像，一个文件，用来创建容器；如果你有 Windows 装机经历，那可以很好理解镜像这个词的含义，反正我年少的时候没少把 Windows 镜像刻盘重装系统。</li>
<li>container：容器，一个可运行的镜像实例，里面运行着一个完整的操作系统，可以做一切你当前操作系统可以做的事情。</li>
<li>Dockerfile：镜像构建的模板，描述镜像构建的步骤。</li>
</ul>
<p>它们之间的关系是，通过 Dockerfile 构建出镜像，然后通过镜像构建容器，容器里可以跑程序。另外，一个镜像可以创建多个容器，每个容器之间是相互隔离的。</p>
<p>对于我们开发人员来说，Docker 可以做到：</p>
<ul>
<li>编写本地代码</li>
<li>使用 Docker 将程序推送到测试环境</li>
<li>发现 bug 后在开发环境下修复，重新部署到测试环境测试</li>
<li>测试完成后，推送到生产环境</li>
</ul>
<p>在这个过程中，Docker 提供的是开发环境、测试环境和生产环境的一致性，细细想一下，是不是挺恐怖的。。。。。</p>
<p>以后我们开发人员再说什么“我本地运行的好好的呀”就甩不了锅了，哈哈。</p>
<p>Java 程序员应该对 Docker 这句宣传语很熟悉：</p>
<blockquote>
<p>Build once，Run anywhere（搭建一次，到处能用）</p>
</blockquote>
<p>Docker 采用的是 CS 架构，客户端与 Docker 守护进程交互，后者负责构建、运行和分发 Docker 容器的工作。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-5583604e-5ef8-4187-b29b-ff8527829141.png"></p>
<p>Docker 的应用场景非常丰富，比如说：</p>
<ul>
<li>自动打包和部署应用</li>
<li>创建轻量、私有的PaaS环境</li>
<li>自动化测试和持续集成&#x2F;部署</li>
<li>部署并扩展Web应用、数据库和后端服务器</li>
<li>创建安全沙盒</li>
<li>轻量级的桌面虚拟化</li>
</ul>
<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>Docker Engine（引擎）需要安装在 64 位的 Linux 服务器上（32 位不支持），并且需要一些先决条件（针对 CentOS 系统）：</p>
<blockquote>
<p>PS：Linux 社区已不再维护 CentOS 8，导致 yum 源需要<a href="https://help.aliyun.com/document_detail/405635.htm">切换</a>，后面打算把系统切换为 Anolis或Alinux</p>
</blockquote>
<ul>
<li>必须是 CentOS 7 或者 8版本，以下版本不支持</li>
<li>centos-extras 存储库必须是启用的，一般是启用的，如果没启用的话，需要手动启用</li>
</ul>
<p>我的云服务器安装的是 CentOS 系统，所以这里就以 CentOS 作为演示环境。我个人更喜欢 RPM（Red-Hat Package Manager，红帽软件包管理器）安装包的方式，简单高效。</p>
<p>第一步，安装 yum-utils 工具包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>第二步，使用 yum-utils 提供的 yum-config-manager 工具配置 Docker 的安装仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>第三步，安装 Docker 引擎（包括 Docker Engine, containerd, 和 Docker Compose）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>第四步，启动 Docker。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>第五步，验证 Docker 是否正确安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>如果出现以下提示信息，就表明 Docker 安装成功了！</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-e1443e64-810b-46e3-9c1c-f144cdca1a35.png"></p>
<p>以上是 Docker 官方提供的安装方式，稍显复杂，其实我们可以用更简洁的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首先安装 Docker</span><br><span class="line">yum -y install docker</span><br><span class="line"></span><br><span class="line"># 然后启动 Docker 服务</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"># 测试安装是否成功</span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure>


<p>Docker 针对 Windows 和 macOS 系统都提供了桌面版，可以到官网下载安装包。</p>
<blockquote>
<p>Docker 下载地址：<a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p>
</blockquote>
<p>我这里以 macOS 为例，M1 芯片可以选择 Apple Chip。下载完成后直接傻瓜式安装就可以了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-f4cd508b-c77b-44a1-979f-b4e9e7ff82ef.png"></p>
<p>安装并启动成功后的界面如下所示:</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-c78c5bea-aa4c-472f-aa69-20854211fd02.png"></p>
<p>按照提示，在终端输入命令 <code>docker run -d -p 80:80 docker/getting-started</code>：</p>
<p>再次回到 Docker 桌面版，可以看到刚刚通过 80 端口在 Docker 中跑起来的 Docker 教程。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-36708add-535a-41d3-bbcf-68e2750e5f16.png"></p>
<p>点击「open in browser」图标就可以在浏览器打开教程文档了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-209a79c6-294f-4f0d-9fe1-1ab62190d4ef.png"></p>
<p>Windows 用户也可以通过我之前推荐的 chocolatey 命令行工具安装。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-4ef004a5-5b96-41eb-8621-65edfbe64f14.png"></p>
<p>（Windows 的安装等下一次拿到小米的笔记本后，我装一个把这部分补充完整）</p>
<h3 id="开启-Docker-远程访问权限"><a href="#开启-Docker-远程访问权限" class="headerlink" title="开启 Docker 远程访问权限"></a>开启 Docker 远程访问权限</h3><p>为了将我们本地的应用程序部署到 Docker 服务器上，我们需要开启一下 Docker 的远程访问权限。</p>
<p>第一步，通过以下命令打开 Docker 配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>

<p>第二步，在 service 节点下编辑 ExecStart 属性，增加 <code>-H tcp://0.0.0.0:2375</code></p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-a1be68f4-cb1b-45b1-ab6a-b39259a3ef39.png"></p>
<p>这样就相当于对外开放了 2375 端口，如果你安装了宝塔面板，记得在安全页放行该端口，同时，云服务器的防火墙也要放开该端口。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-9bddcf0e-c6a7-414d-82ef-7881009ea6c9.png"></p>
<p>配置完成后，重启 Docker。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure>

<p>在浏览器地址栏输入 <code>http://ip:2375/version</code> 测试一下是否生效。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-29852364-5b55-43b4-a7fa-6a9c4a592606.png"></p>
<p>之后，可以在 Intellij IDEA 中配置一下 Docker 的 TCP socket，如果出现 connection successful 就表明链接成功了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-a6e42514-8740-48ac-8baf-b97f49cb1818.png"></p>
<h3 id="使用-Docker-部署-Spring-Boot"><a href="#使用-Docker-部署-Spring-Boot" class="headerlink" title="使用 Docker 部署 Spring Boot"></a>使用 Docker 部署 Spring Boot</h3><p>第一步，新建一个简单的 Spring Boot 项目。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-3f748cc6-2efe-487d-9799-f02794145aec.png"></p>
<p>一个非常简单的 Web 项目，只有一个控制器，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Docker，我是沙雕&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>@RequestMapping、@RestController 注解我们在前几个章节介绍过了，也就是表明我们这是一个 SpringMVC 的项目，<code>/</code> 路径意味着我们只要在浏览器地址栏输入 <code>localhost:8080</code> 就可以发送请求了，响应结果为 “Docker，你好”。</p>
<p>启动服务后，可以通过 Intellij IDEA 的 HTTP Client 验证一下。</p>
<p>第二步，构建 Spring Boot 项目的 Docker 镜像文件 Dockerfile。</p>
<p>在项目根目录新建 Dockerfile 文件，见下图位置。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-08d6ce30-8192-4a7e-8bdc-95adb91c7c74.png"></p>
<p>具体内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">ARG JAR_FILE=target/*.jar</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>


<ul>
<li><code>FROM openjdk:8-jdk-alpine</code>：表示使用 JDK8 为基础镜像。</li>
<li><code>ARG JAR_FILE=target/*.jar</code>：表示定义一个参数名为 JAR_FILE，值为 <code>target/*.jar</code> 的构建参数</li>
<li><code>COPY $&#123;JAR_FILE&#125; app.jar</code>：表示把 target 目录下的 jar 文件复制一份新的到镜像内的 app.jar 文件</li>
<li><code>ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</code>：表示通过 <code>java -jar</code> 的形式运行 <code>app.jar</code>，ENTRYPOINT 用来配置容器启动时的运行命令，第一个参数是运行命令，后面是一个一个参数。</li>
</ul>
<p>第三步，在 pom.xml 文件中添加 Maven 的 Docker 插件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;dockerHost&gt;http://ip:2375&lt;/dockerHost&gt;</span><br><span class="line">        &lt;imageName&gt;itwanger/$&#123;project.artifactId&#125;&lt;/imageName&gt;</span><br><span class="line">        &lt;imageTags&gt;</span><br><span class="line">            &lt;imageTag&gt;$&#123;project.version&#125;&lt;/imageTag&gt;</span><br><span class="line">        &lt;/imageTags&gt;</span><br><span class="line">        &lt;forceTags&gt;true&lt;/forceTags&gt;</span><br><span class="line">        &lt;dockerDirectory&gt;$&#123;project.basedir&#125;&lt;/dockerDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>executions</code> 节点下添加 docker:build，表示在执行 mvn:package 打包的时候顺带构建一下 Docker 镜像。</li>
<li>在 <code>configuration</code> 节点下添加 Docker 主机的地址、镜像的名字、镜像的版本、镜像文件的目录、以及 resources 节点下配置的 jar 包位置和名称等。</li>
</ul>
<p>配置搞定后，接下来就是对项目进行打包，可以直接点击 Maven 面板中的 package 进行打包。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-1932f285-bb8d-4225-af6e-014ed2c9104b.png"></p>
<p>首次打包需要下载一些基础镜像，打包成功后，可以在 Docker 容器中查看我们刚刚打包好的镜像，命令 <code>docker images</code>。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-730b4f5b-d556-4f73-9dfc-b22152d86f08.png"></p>
<p>接下来，我们就可以启动这个镜像的容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name itwanger -p 8080:8080 itwanger/springboot-docker:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>: 后台运行容器，并返回容器ID；</li>
<li><code>--name</code>: 为容器指定一个名称 itwanger；</li>
<li><code>-p</code>: 指定端口映射，格式为：主机(宿主)端口:容器端口</li>
</ul>
<p>然后在浏览器中访问 8080 端口，就可以看到我们的应用程序在 Docker 上成功运行了。</p>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="Intellij-IDEA-直连-Docker"><a href="#Intellij-IDEA-直连-Docker" class="headerlink" title="Intellij IDEA 直连 Docker"></a>Intellij IDEA 直连 Docker</h3><p>新版的 Intellij IDEA 中已经默认继承了 Docker，所以我们可以通过 services 面板打开 Docker，直接进行操作。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/docker-6b4fbbb0-3986-403b-9d7e-7e50cf27b499.png"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把项目部署到云服务器</title>
    <url>/article/112216.html</url>
    <content><![CDATA[<h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><p>我们需要一台云服务器，我之前白嫖过一台丐版的，1 核1G 内存，并且已经安装了宝塔面板。</p>
<p>这是从宝塔面板首页看到的服务器配置详情。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10ef01787c-ee09-4474-a182-70bd6a2daf72.png"></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>登录宝塔面板，点击「数据库」→「添加数据库」，填写数据库名，宝塔面板会自动帮我们创建一个和数据库同名的账号，注意访问权限选择「本地服务器」。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10b64e7890-552d-47d5-91bd-03d74bff7974.png"></p>
<p>在 codingmore 栏目中点击「导入」「从本地上传」编程喵的数据库文件。上传完成后点击导入。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10eec6b672-9089-414b-9f69-65cae18ae45d.png"></p>
<p>DB 文件放在 coding-more&#x2F;doc 目录下。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-102f8aa2a1-1443-49e6-85d0-6b983863d161.png"></p>
<p>建议先做一次备份，点击「无备份」「备份」就可以将我们的数据库文件备份下来了，如果后面想恢复的话，直接点击「恢复」就可以了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10c8edb874-95ad-405c-a57c-9c8b9fab8f6e.png"></p>
<p>记住用户名，并复制密码，然后在数据库条目中点击「管理」</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1032b5cafc-74ef-4e62-b65d-7e36980c14ed.png"></p>
<p>填写用户名和密码后，点击执行。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-105579299a-bc0c-495d-a41b-31d9214835f3.png"></p>
<p>就可以看到编程喵的数据库文件了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-100877b273-1ba2-40ed-8f96-0031c75e3680.png"></p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><a href="https://javabetter.cn/nginx/nginx.html">Nginx</a> 是一个高性能的 HTTP 和反向代理 Web 服务器，基本上就变成了一个服务器必须安装的前置条件之一。</p>
<p>宝塔面板中安装 Nginx 比较简单，直接在软件商店中搜「Nginx」就可以点击安装了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10cedec531-ae0e-402c-87ca-ee705a469288.png"></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>宝塔面板中安装 Redis 也比较简单，直接在软件商店中搜「Redis」就可以点击安装了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10eab69fa2-b7cd-419a-a290-0cc0da2b30c3.png"></p>
<h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><h3 id="1）codingmore-admin"><a href="#1）codingmore-admin" class="headerlink" title="1）codingmore-admin"></a>1）codingmore-admin</h3><p>编程喵的管理后端，注意修改生产环境下的 MySQL 用户名和密码，在 application-prod.yml 文件中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-100a38b5dd-ecd4-4734-bf6a-448397fa5463.png"></p>
<p>然后把 application.yml 文件中的 active 修改为 prod 生产环境。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10dd44a2ce-600d-43b1-8707-4de25287eed9.png"></p>
<p>替换 OSS 配置。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-108ebb40d9-64a1-43cd-89fd-4b83e47025de.png"></p>
<h3 id="2）codingmore-web"><a href="#2）codingmore-web" class="headerlink" title="2）codingmore-web"></a>2）codingmore-web</h3><p>编程喵的 Web 前端（网站门户、文章展示&#x2F;文章详情等），注意修改生产环境下的 MySQL 用户名和密码，在 application-prod.yml 文件中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1066ba1162-a198-45e4-87ad-717c62fae6c7.png"></p>
<p>然后把 application.yml 文件中的 active 修改为 prod 生产环境。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10560633b8-439d-418e-a3bb-61f21efbae9f.png"></p>
<p>然后就可以双击 Maven 的 package 打包了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1089745ff7-9222-4d49-b6b9-66fbddba1e52.png"></p>
<h3 id="3）codingmore-admin-web"><a href="#3）codingmore-admin-web" class="headerlink" title="3）codingmore-admin-web"></a>3）codingmore-admin-web</h3><p>admin 管理端的前端界面。在 Visual Studio Code 中，现在终端中执行 <code>yarn install</code> 安装项目的依赖插件。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10d6a9cbaf-fd70-4567-b6b0-b2c50b61407a.png"></p>
<p>再执行 <code>yarn run build</code> 就可以构建 codingmore-admin-web 的静态页面了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-101aedea50-7f21-4199-9ff2-c264b614e711.png"></p>
<p>会在项目的根目录中生成一个 dist 目录，里面就是打包好的管理端静态页面。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10128e58f4-172a-4c77-acf1-324ed310412c.png"></p>
<p>打包的时候有两个要点要补充下，在 config 目录下有三个配置文件，dev.env.js 是开发环境下的一些配置，index.js 是主配置，prod.env.js 是生产环境下的配置。</p>
<p>为了提高网站的性能，我们需要关闭 source map，设置 <code>productionSourceMap: false</code>，同时开启 js 和 css 的文件压缩功能。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10c2b78cd1-4c55-4fce-9c7a-0afbdd21a659.png"></p>
<p>这样打包后的文件大小就会小很多，放到服务器上也能减少网络请求的响应时间。</p>
<p>可以看得出，最大的一个 js 文件为 3.7M，压缩版只有 662kb，体积缩小了五倍。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1009d6dc89-05a3-4a43-972b-bbad4bdd34e5.png"></p>
<h2 id="将打包好的文件上传到服务器"><a href="#将打包好的文件上传到服务器" class="headerlink" title="将打包好的文件上传到服务器"></a>将打包好的文件上传到服务器</h2><p>在宝塔面板中点击「FTP」「添加 FTP」。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1047c54369-e3af-48ea-8143-ea1dbce36894.png"></p>
<p>点击「根目录」</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-103cdb501e-0145-48b2-ac3f-96b6e99e8ecf.png"></p>
<p>跳转到文件页。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-106d8e3ef4-e032-4c2d-b872-c7ede968a051.png"></p>
<p>点击上传，在 target 目录下选择上传的两个 jar 包，admin 和 web。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10b1544314-3fc7-4fba-a9e5-28a1760d3517.png"></p>
<p>点击「开始上传」</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10ffe802fb-da43-404a-aaaf-f5b5eb4bdcc3.png"></p>
<p>还有 codingmore-admin-web 的静态文件。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10f55854dd-b6a5-4a46-8232-e21bb03b788f.png"></p>
<h2 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h2><p>在软件商店里搜「<strong>Java</strong>」关键字，可以看到一个「<strong>Java 项目一键部署 3.5</strong>」的插件，安装它。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10e784ae11-5d73-41c3-929e-60f7c1114f73.png"></p>
<p>进入「Java 项目一键部署」面板。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-102724c169-4f6c-4208-aa3e-ab4936a14e7a.png"></p>
<p>可以在「容器管理」面板中选择 Tomcat 8 安装下，如果没有安装 JDK，在安装 Tomcat 8 的时候会默认安装一个 JDK 1.8。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1059bcd44e-be2d-4c7b-81c3-c974f5c9a33a.png"></p>
<p>进入 Spring Boot 面板，点击「添加项目」，点击「项目路径」右侧的文件夹图标，就可以上传部署我们的 Spring Boot 项目了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10f39e778b-2d59-4087-bd89-86d71231ff6e.png"></p>
<h3 id="codingmore-web（网站前端）"><a href="#codingmore-web（网站前端）" class="headerlink" title="codingmore-web（网站前端）"></a>codingmore-web（网站前端）</h3><p>先选择 codingmore-web。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-108d03852e-c207-442d-9ce9-770c6a16710b.png"></p>
<p>填写域名（编程喵的域名为 <a href="codingmore.top">codingmore.top</a>），修改端口号为 8081，application.yml 文件中定义的。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10358f631c-27c8-4460-a00e-5c17a3077f28.png"></p>
<p>点击确定。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1099646018-e244-421c-9232-4f40c4e07444.png"></p>
<p>可以看到服务已经在启动了，点「日志」看一下。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1053ab9712-5874-4650-92da-e6978803c4de.png"></p>
<p>没问题。</p>
<p>也可以在这个路径下使用终端工具看日志。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-107242861b-2cfc-4eb2-8414-6afade214a74.png"></p>
<p>在安全面板里确认一下 8081 端口是否放开。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-109c7d80a2-fb84-43b9-86fc-670221607b22.png"></p>
<p>确认放开后，打开 Chrome 浏览器的无痕模式，输入 IP+端口号。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-109f8efbcd-3e6f-4877-ad90-b766dda67879.png"></p>
<p>通过域名+端口号的形式也可以访问到。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10f50b5c71-35bd-439c-bb82-07348a5155d3.png"></p>
<h3 id="codingmore-admin（网站管理端）"><a href="#codingmore-admin（网站管理端）" class="headerlink" title="codingmore-admin（网站管理端）"></a>codingmore-admin（网站管理端）</h3><p>再次进入 「Java 项目一键部署」Spring Boot 面板中，添加 codingmore-admin 项目。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1001b5b9f3-05f8-4fdf-9c8a-111ec449826f.png"></p>
<p>稍等片刻，来看一下日志。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-103a4c0249-f250-4199-ba3c-eeb1ca005bd0.png"></p>
<p>启动没问题。</p>
<p>codingmore-admin 只是一个后端服务，界面是用 vue 完成的，所以我们此时可以通过 Swagger 来确认一下接口是否可以正常访问。</p>
<p>先放行 9002 端口。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10f6b25066-3ffa-4dfc-a61c-b6ebb16e339b.png"></p>
<p>在浏览器地址栏里输入 <code>http://www.codingmore.top:9002/doc.html</code>，可以看到我们用 Knife4j+Swagger 生成的 API 文档接口。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-10a04aa484-a7f1-48f1-a3ff-1525b9bd7035.png"></p>
<p>OK，这样就可以验证我们的 admin 端服务也正确运行了。</p>
<p>随后，为了减少服务器被攻击的可能性，我们关掉 9002 的端口。</p>
<h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><h3 id="codingmore-web"><a href="#codingmore-web" class="headerlink" title="codingmore-web"></a>codingmore-web</h3><p>域名+端口号虽然可以访问，但不够优雅，我们想直接访问域名 codingmore.top，该怎么办呢？</p>
<p>可以使用 <a href="https://javabetter.cn/nginx/nginx.html">Nginx</a> 进行端口转发。</p>
<p>Nginx 的实现原理是，用 Nginx 监听 80 端口，当有 HTTP 请求到来时，将 HTTP 请求的 HOST 等信息与配置文件进行匹配并转发给对应的端口。</p>
<p>比如说，当用户访问 codingmore.top 时，Nginx 从配置文件中得知这是一个 HTTP 请求，于是将此请求转发给 8081 端口的应用处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream codingmore_web_pool&#123;</span><br><span class="line">    server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  codingmore.top;</span><br><span class="line">    access_log logs/codingmore_web.log;</span><br><span class="line">    error_log logs/codingmore_web.error;</span><br><span class="line">    </span><br><span class="line">    #将所有请求转发给pool池的应用处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://codingmore_web_pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是所谓的端口转发，由软件统一监听某个域名上的某个端口（一般是80端口），当访问服务器的域名和端口符合要求时，就按照配置转发给指定的 Tomcat 服务器处理。我们常用的 Nginx 也有端口转发功能。</p>
<p>OK，原理了解完后，我们把这段配置复制到宝塔面板中的 Nginx 配置中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1053849d03-ca6c-4871-9103-b65238557c50.png"></p>
<p>点击「保存」。</p>
<p>再在浏览器中访问 <a href="http://www.codingmore.top/">codingmore.top</a> 就可以请求到内容了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-106302a681-0dbe-4d76-ac54-243ef67914c7.png"></p>
<p>既然如此，我们顺带把 8081 端口给关掉，减少一个服务器被攻击的可能性。</p>
<p>OK，这样我们就完成了 codingmore-web 也就是编程喵🐱前端的服务部署了。</p>
<h3 id="codingmore-admin-web"><a href="#codingmore-admin-web" class="headerlink" title="codingmore-admin-web"></a>codingmore-admin-web</h3><p>codingmore-admin-web 打包后的文件是静态的，所以我们只需要在 Nginx 里添加 admin 的配置路径就 OK 了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream codingmore_web_pool&#123;</span><br><span class="line">    server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  codingmore.top;</span><br><span class="line">    access_log /home/www/codingmore_web.log;</span><br><span class="line">    error_log /home/www/codingmore_web.error;</span><br><span class="line"></span><br><span class="line">    location /admin &#123;</span><br><span class="line">        alias /www/wwwroot/itwanger/dist/; # 根目录</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #将所有请求转发给pool池的应用处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://codingmore_web_pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 server 中增加了一个 admin 的 location，也就是说，当我们访问 <a href="http://codingmore.top/admin">codingmore.top&#x2F;admin</a> 的时候，就去请求 <code>/www/wwwroot/itwanger/dist/</code> 目录下的静态文件。</p>
<p>这里讲一下 root 和 alias 的区别：</p>
<ul>
<li>root：实际访问的地址前缀是  root  + 请求的 path路径，即 <code>admin =&gt;  /www/wwwroot/itwanger/dist/admin</code></li>
<li>alias:  实际访问的就是 <code>/www/wwwroot/itwanger/dist</code></li>
</ul>
<p>注意两者的区别。我们来访问下<a href="http://codingmore.top/admin">codingmore.top&#x2F;admin</a>：</p>
<p><img src="https://cdn.tobebetterjavaer.com/codingmore/images/2022-06-1050bb8a6a-aeee-4514-a62a-cd87cb82b3d4.png"></p>
<p>OK。</p>
<p>编程喵🐱是一个前后端分离项目，前端的请求如何访问后端的 API 接口呢？简单聊一下。</p>
<p>打开 codingmore-admin-web&#x2F;config&#x2F;prod.env.js 文件，里面有一个 VUE_APP_BASE_API 属性，它的值为 <code>/api</code>，也就意味着前端的请求会发送到 <code>/api</code> 这个前缀路径下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  NODE_ENV: &#x27;&quot;production&quot;&#x27;,</span><br><span class="line">  VUE_APP_BASE_API: &#x27;&quot;/api&quot;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们的 codingmore-admin 后端服务是跑在 9002 端口下的，这就意味着，我们需要在 Nginx 中增加一个路径，将 api 前缀的请求转发到 9002 下。</p>
<p>OK，来看一下完整的配置内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream codingmore_web_pool&#123;</span><br><span class="line">    server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream codingmore_admin_pool&#123;</span><br><span class="line">    server 127.0.0.1:9002/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  codingmore.top;</span><br><span class="line">    access_log /home/www/codingmore_web.log;</span><br><span class="line">    error_log /home/www/codingmore_web.error;</span><br><span class="line"></span><br><span class="line">    location /admin &#123;</span><br><span class="line">        alias /www/wwwroot/itwanger/dist/; # 根目录</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://codingmore_admin_pool;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #将所有请求转发给pool池的应用处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http://codingmore_web_pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
        <tag>生产环境</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器、拦截器、监听器</title>
    <url>/article/112212.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先说作用。</p>
<ul>
<li>过滤器（Filter）：当有一堆请求，只希望符合预期的请求进来。</li>
<li>拦截器（Interceptor）：想要干涉预期的请求。</li>
<li>监听器（Listener）：想要监听这些请求具体做了什么。</li>
</ul>
<p>再说区别。</p>
<p>过滤器是在请求进入容器后，但还没有进入 Servlet 之前进行预处理的。如下图所示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-2a28621b-2cc1-4d29-87a1-cf6a01d95443.png"></p>
<p>拦截器是在请求进入控制器（Controller） 之前进行预处理的。</p>
<p>虚线内就是过滤器和拦截器的作用范围：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-dd48851b-c123-4fd8-b82d-9ae87b33745d.png"></p>
<p>过滤器依赖于 Servlet 容器，而拦截器依赖于 Spring 的 IoC 容器，因此可以通过注入的方式获取容器当中的对象。</p>
<p>监听器用于监听 Web 应用中某些对象的创建、销毁、增加、修改、删除等动作，然后做出相应的处理。</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul>
<li>过滤敏感词汇（防止sql注入）</li>
<li>设置字符编码</li>
<li>URL级别的权限访问控制</li>
<li>压缩响应信息</li>
</ul>
<p>过滤器的创建和销毁都由 Web 服务器负责，Web 应用程序启动的时候，创建过滤器对象，为后续的请求过滤做好准备。</p>
<p>过滤器可以有很多个，一个个过滤器组合起来就成了 FilterChain，也就是过滤器链。</p>
<p>在 Spring 中，过滤器都默认继承了 OncePerRequestFilter，顾名思义，OncePerRequestFilter 的作用就是确保一次请求只通过一次过滤器，而不重复执行。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-aaa1c537-c8ed-4c5d-b27f-93c1409f2748.png"></p>
<p>在编程喵实战项目中，我们就是通过继承 OncePerRequestFilter 来实现 JWT 登录授权过滤的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从客户端请求中获取 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> request.getHeader(<span class="built_in">this</span>.tokenHeader);</span><br><span class="line">        <span class="comment">// 该 JWT 是我们规定的格式，以 tokenHead 开头</span></span><br><span class="line">        <span class="keyword">if</span> (authHeader != <span class="literal">null</span> &amp;&amp; authHeader.startsWith(<span class="built_in">this</span>.tokenHead)) &#123;</span><br><span class="line">            <span class="comment">// The part after &quot;Bearer &quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">authToken</span> <span class="operator">=</span> authHeader.substring(<span class="built_in">this</span>.tokenHead.length());</span><br><span class="line">            <span class="comment">// 从 JWT 中获取用户名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;checking username:&#123;&#125;&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// SecurityContextHolder 是 SpringSecurity 的一个工具类</span></span><br><span class="line">            <span class="comment">// 保存应用程序中当前使用人的安全上下文</span></span><br><span class="line">            <span class="keyword">if</span> (username != <span class="literal">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 根据用户名获取登录用户信息</span></span><br><span class="line">                <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="comment">// 验证 token 是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                    <span class="comment">// 将登录用户保存到安全上下文中</span></span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(userDetails,</span><br><span class="line">                            <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用 Spring Initializr 来新建一个 Web 项目 codingmore-filter-interceptor-listener。</p>
<p>添加一个过滤器 MyFilter ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;myFilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">&quot;Execute cost=&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@WebFilter 注解用于将一个类声明为过滤器，urlPatterns 属性用来指定过滤器的 URL 匹配模式，filterName 用来定义过滤器的名字。</p>
<p>MyFilter 过滤器的逻辑非常简单，重写了 Filter 的三个方法，在 doFilter 方法中加入了时间戳的记录。</p>
<p>然后我们在项目入口类上加上 @ServletComponentScan 注解，这样过滤器就会自动注册。</p>
<p>启动服务器，访问任意的 URL。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-c865b6d2-30d3-435b-a930-c732caed17ce.png"></p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul>
<li>登录验证，判断用户是否登录</li>
<li>权限验证，判断用户是否有权限访问资源，如校验token</li>
<li>日志记录，记录请求操作日志（用户ip，访问时间等），以便统计请求访问量</li>
<li>处理cookie、本地化、国际化、主题等</li>
<li>性能监控，监控请求处理时长等</li>
</ul>
<p>我们来写一个简单的拦截器 LoggerInterceptor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;preHandle&#123;&#125;...&quot;</span>,request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个拦截器必须实现 HandlerInterceptor 接口，preHandle 方法是 Controller 方法调用前执行，postHandle  是 Controller 方法正常返回后执行，afterCompletion 方法无论 Controller 方法是否抛异常都会执行。</p>
<p>只有 preHandle 返回 true 的话，其他两个方法才会执行。</p>
<p>如果 preHandle 返回 false 的话，表示不需要调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。</p>
<p>再来一个 InterceptorConfig 对拦截器进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoggerInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Configuration 注解用于定义配置类，干掉了以往 Spring 繁琐的 xml 配置文件。</p>
<p>编写一个用于被拦截的控制器 MyInterceptorController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/myinterceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptorController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;火锅是傻X&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RestController 注解相当于 @Controller + @ResponseBody 注解，@ResponseBody 注解用于将 Controller 方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-27c3f03f-8cca-4cbe-84cb-005075c0b8c9.png"></p>
<p>启动服务器，访问 <code>http://localhost:8080/myinterceptor/hello</code>。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-dcd99eeb-c00e-4a7a-a1c2-f8c5ca952aed.png"></p>
<p>在控制台可以看到拦截器中的日志信息：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-20bb0987-77c8-4069-a59f-bbd2d5584d8c.png"></p>
<p>无论是过滤器还是拦截器，都属于AOP（面向切面编程）思想的具体实现。除了这两种实现之外，还有另一种更灵活的AOP实现技术，即 Aspect，在编程喵实战项目里，你可以看到 Aspect 具体实现。</p>
<p>比如说统一日志切面 WebLogAspect，就是用来记录请求信息的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.codingmore.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;webLog()&quot;, returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前请求对象</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        webLog.setStartTime(startTime);</span><br><span class="line">        webLog.setUri(request.getRequestURI());</span><br><span class="line">        logMap.put(<span class="string">&quot;parameter&quot;</span>,webLog.getParameter());</span><br><span class="line">        logMap.put(<span class="string">&quot;spendTime&quot;</span>,webLog.getSpendTime());</span><br><span class="line">        logMap.put(<span class="string">&quot;description&quot;</span>,webLog.getDescription());</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;&quot;</span>, JSONUtil.parse(webLog));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据方法和传入的参数获取请求参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getParameter</span><span class="params">(Method method, Object[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过拦截后的请求信息大概是这样的：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/springboot/Filter-Interceptor-Listener-7a4b219d-bd3e-435e-a2dc-93f4fe4e8cc2.png"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【开发必备】Spring AOP 的灵活运用</title>
    <url>/article/112234.html</url>
    <content><![CDATA[<h1 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h1><p>AOP又名Aspect Oriented Programming 意为 ‘面向切面编程’通过预编译和运行期间动态代理来实现程序功能的统一维护的一种技术。</p>
<h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><h2 id="AOP-的优势和应用场景"><a href="#AOP-的优势和应用场景" class="headerlink" title="AOP 的优势和应用场景"></a>AOP 的优势和应用场景</h2><h1 id="Spring-AOP-原理"><a href="#Spring-AOP-原理" class="headerlink" title="Spring AOP 原理"></a>Spring AOP 原理</h1><h2 id="代理模式和动态代理"><a href="#代理模式和动态代理" class="headerlink" title="代理模式和动态代理"></a>代理模式和动态代理</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 的扩展接口汇总大全（都给你们整理好啦！）</title>
    <url>/article/112233.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Spring的核心理念蕴含着容器的奥妙。在容器焕然一新的瞬间，外部世界看似平静，却不知内部却是波涛汹涌，掀起惊涛骇浪，浩浩荡荡。Spring<br>Boot更进一步地封装了Spring框架，秉承着约定优于配置的原则，借助自动装配的机制。有时候，只需引入一个依赖，便能轻松实现功能的装配，几乎无需额外的配置。</p>
<h1 id="调用顺序图"><a href="#调用顺序图" class="headerlink" title="调用顺序图"></a>调用顺序图</h1><blockquote>
<p>来自大佬的图<br><img src="https://upload-images.jianshu.io/upload_images/7880910-df5c16edbf034676.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p>
</blockquote>
<h1 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h1><h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><blockquote>
<p>org.springframework.context.ApplicationContextInitializer</p>
</blockquote>
<p>实现 ApplicationContextInitializer 接口的类，可以在 Spring 容器初始化的早期阶段介入，并在容器刷新之前对应用程序上下文进行必要的定制。<br>比如设置<code>环境属性</code>、<code>激活配置文件</code>、<code>注册监听器</code>等操作，以便在容器刷新后应用这些配置。<br>这为开发人员提供了更大的灵活性和控制力，使他们能够更好地适应应用程序的特定需求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<h2 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h2><blockquote>
<p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p>
</blockquote>
<p>这个接口在读取项目中的beanDefinition之后执行，提供的扩展点<br>使用场景：可以在这里<code>动态注册自己的beanDefinition</code>，也可以加载classpath之外的bean</p>
<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><blockquote>
<p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p>
</blockquote>
<p>这个接口是beanFactory的扩展接口，调用时机在实例化bean之前，spring读取beanDefinition信息之后。</p>
<p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的<code>元信息</code>。</p>
<h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><blockquote>
<p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p>
</blockquote>
<p>该接口<code>继承了BeanPostProcess接口</code></p>
<ul>
<li>BeanPostProcess接口只在bean的初始化阶段进行扩展,注入spring上下文前后。</li>
<li>InstantiationAwareBeanPostProcessor接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</li>
<li>InstantiationAwareBeanPostProcessor接口主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<code>实例化阶段</code><br>和<code>初始化阶段</code><ul>
<li>postProcessBeforeInstantiation：实例化bean之前，相当于new这个bean之前</li>
<li>postProcessAfterInstantiation：实例化bean之后，相当于new这个bean之后</li>
<li>postProcessPropertyValues：bean已经实例化完成，在属性注入时阶段触发，@Autowired, @Resource等注解原理基于此方法实现</li>
<li>postProcessBeforeInitialization：初始化bean之前，相当于把bean注入spring上下文之前</li>
<li>postProcessAfterInitialization：初始化bean之后，相当于把bean注入spring上下文之后</li>
</ul>
</li>
</ul>
<p>使用场景：这个扩展点非常实用 ，无论是写中间件和业务中，都能利用这个特性</p>
<h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><blockquote>
<p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p>
</blockquote>
<p>该扩展接口有3个触发点方法：</p>
<ul>
<li>predictBeanType：该触发点发生在postProcessBeforeInstantiation之前(在图上并没有标明，因为一般不太需要扩展这个点)<br>，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用BeanFactory.getType(name)<br>时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li>
<li></li>
</ul>
<h2 id="determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。"><a href="#determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。" class="headerlink" title="determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。"></a>determineCandidateConstructors：该触发点发生在postProcessBeforeInstantiation之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</h2><p>getEarlyBeanReference：该触发点发生在postProcessAfterInstantiation之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</p>
<h2 id="BeanFactoryAware"><a href="#BeanFactoryAware" class="headerlink" title="BeanFactoryAware"></a>BeanFactoryAware</h2><blockquote>
<p>org.springframework.beans.factory.BeanFactoryAware</p>
</blockquote>
<p>可以在bean实例化之后，但还未初始化之前，也就是Setter之前。拿到<br>BeanFactory，在这个时候，可以对每个bean作特殊化的定制。也或者可以把BeanFactory拿到进行缓存，日后使用。</p>
<h2 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h2><blockquote>
<p>org.springframework.context.support.ApplicationContextAwareProcessor</p>
</blockquote>
<p>触发的时机在bean实例化之后，初始化之前</p>
<ul>
<li>EnvironmentAware：用于获取EnvironmentAware的一个扩展类，这个变量非常有用，<br>可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li>
<li>EmbeddedValueResolverAware：用于获取StringValueResolver的一个扩展类，<br>StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取，如果实现了这个Aware接口，把StringValueResolver缓存起来，通过这个类去获取String类型的变量，效果是一样的。</li>
<li>ResourceLoaderAware：用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li>
<li></li>
</ul>
<p>ApplicationEventPublisherAware：用于获取ApplicationEventPublisher的一个扩展类，ApplicationEventPublisher可以用来发布事件，结合ApplicationListener来共同使用，下文在介绍ApplicationListener时会详细提到。这个对象也可以通过spring注入的方式来获得。</p>
<ul>
<li>MessageSourceAware：用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</li>
<li></li>
</ul>
<p>ApplicationContextAware：用来获取ApplicationContext的一个扩展类，ApplicationContext应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时ApplicationContext也实现了BeanFactory，MessageSource，ApplicationEventPublisher等接口，也可以用来做相关接口的事情。</p>
<h2 id="BeanNameAware"><a href="#BeanNameAware" class="headerlink" title="BeanNameAware"></a>BeanNameAware</h2><blockquote>
<p>org.springframework.beans.factory.BeanNameAware</p>
</blockquote>
<p>触发点在bean的初始化之前，也就是postProcessBeforeInitialization之前，这个类的触发点方法只有一个：setBeanName</p>
<p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p>
<h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><blockquote>
<p>javax.annotation.PostConstruct</p>
</blockquote>
<p>类似于InitializingBean 接口<br>其作用是在bean的初始化阶段，如果对一个方法标注了@PostConstruct，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在postProcessBeforeInitialization之后，InitializingBean.afterPropertiesSet之前。<br>使用场景：用户可以对某一方法进行标注，来进行初始化某一个类里的属性</p>
<h2 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h2><blockquote>
<p>org.springframework.beans.factory.InitializingBean</p>
</blockquote>
<p>类似于@PostConstruct<br>用来初始化bean的。InitializingBean接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet方法</code><br>，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在postProcessAfterInitialization之前。</p>
<p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><blockquote>
<p>org.springframework.beans.factory.FactoryBean</p>
</blockquote>
<p>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T><br>的形式</p>
<p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿ProxyFactoryBean的功能。</p>
<h2 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h2><blockquote>
<p>org.springframework.beans.factory.SmartInitializingSingleton</p>
</blockquote>
<p>在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。</p>
<p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些<code>后置的业务处理</code>。</p>
<h2 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h2><blockquote>
<p>org.springframework.boot.CommandLineRunner</p>
</blockquote>
<p>触发时机为整个项目启动完毕后，自动执行。如果有多个CommandLineRunner，可以利用@Order来进行排序。</p>
<p>使用场景：用户扩展此接口，进行启动项目之后一些业务的<code>预处理</code>。</p>
<h2 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h2><blockquote>
<p>org.springframework.beans.factory.DisposableBean</p>
</blockquote>
<p>触发时机为当此对象销毁时，会自动执行这个方法。</p>
<h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><blockquote>
<p>org.springframework.context.ApplicationListener</p>
</blockquote>
<p>触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。</p>
<ul>
<li>ContextRefreshedEvent</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用 refresh()</span><br><span class="line">方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean</span><br><span class="line">被预实例化，ApplicationContext容器已就绪可用。</span><br></pre></td></tr></table></figure>

<ul>
<li>ContextStartedEvent</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当使用  ConfigurableApplicationContext  （ApplicationContext子接口）接口中的  start()  方法启动  ApplicationContext时，该事件被发布。</span><br><span class="line">你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</span><br></pre></td></tr></table></figure>

<ul>
<li>ContextStoppedEvent</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当使用 ConfigurableApplicationContext接口中的 stop()停止ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</span><br></pre></td></tr></table></figure>

<ul>
<li>ContextClosedEvent</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">当使用 ConfigurableApplicationContext接口中的 close()方法关闭 ApplicationContext 时，该事件被发布。</span><br><span class="line">一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</span><br></pre></td></tr></table></figure>

<ul>
<li>RequestHandledEvent</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。</span><br><span class="line">在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</span><br></pre></td></tr></table></figure>

<h2 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h2><blockquote>
<p>org.aopalliance.intercept.MethodInterceptor</p>
</blockquote>
<p>这是一个接口，用于实现方法拦截器。方法拦截器可以在目标方法执行前、执行后或异常抛出时拦截方法调用，并执行相应的逻辑。</p>
<h2 id="StaticMethodMatcherPointcut"><a href="#StaticMethodMatcherPointcut" class="headerlink" title="StaticMethodMatcherPointcut"></a>StaticMethodMatcherPointcut</h2><blockquote>
<p>org.springframework.aop.support.StaticMethodMatcherPointcut</p>
</blockquote>
<p>这是一个 Spring 框架中的类，用于定义静态方法匹配切点。它提供了一种方式来匹配目标对象中的方法，以确定是否应该应用切面的通知逻辑。</p>
<h2 id="AbstractBeanFactoryPointcutAdvisor"><a href="#AbstractBeanFactoryPointcutAdvisor" class="headerlink" title="AbstractBeanFactoryPointcutAdvisor"></a>AbstractBeanFactoryPointcutAdvisor</h2><blockquote>
<p>org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</p>
</blockquote>
<p>这是一个抽象类，用于实现切面通知者。它结合了切点和通知，提供了一种将切面应用于 Spring Bean 的方式。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>扩展</tag>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava:Google开源的Java工具库，太强大了</title>
    <url>/article/112213.html</url>
    <content><![CDATA[<h2 id="Guava工具库"><a href="#Guava工具库" class="headerlink" title="Guava工具库"></a>Guava工具库</h2><h3 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h3><p>你好呀，我是 Guava。</p>
<p>我由 Google 公司开源，目前在 GitHub 上已经有 39.9k 的铁粉了，由此可以证明我的受欢迎程度。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/guava-01.png"></p>
<p>我的身体里主要包含有这些常用的模块：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等。新版的 JDK 中已经直接把我引入了，可想而知我有多优秀，忍不住骄傲了。</p>
<p>这么说吧，学好如何使用我，能让你在编程中变得更快乐，写出更优雅的代码！</p>
<h3 id="引入-Guava"><a href="#引入-Guava" class="headerlink" title="引入 Guava"></a>引入 Guava</h3><p>如果你要在 Maven 项目使用我的话，需要先在 pom.xml 文件中引入我的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;30.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>一点要求，JDK 版本需要在 8 以上。</p>
<h3 id="03、基本工具"><a href="#03、基本工具" class="headerlink" title="03、基本工具"></a>03、基本工具</h3><p>Doug Lea，java.util.concurrent 包的作者，曾说过一句话：“<a href="https://javabetter.cn/exception/npe.html">null 真糟糕</a>”。Tony Hoare，图灵奖得主、快速排序算法的作者，当然也是 null 的创建者，也曾说过类似的话：“null 的使用，让我损失了十亿美元。”鉴于此，我用 Optional 来表示可能为 null 的对象。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/guava-20230329172935.png"></p>
<p>代码示例如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(5);</span><br><span class="line">possible.isPresent(); // returns true</span><br><span class="line">possible.get(); // returns 5</span><br></pre></td></tr></table></figure>

<p>我大哥 Java 在 JDK 8 中新增了 <a href="https://javabetter.cn/java8/optional.html">Optional 类</a>，显然是从我这借鉴过去的，不过他的和我的有些不同。</p>
<ul>
<li>我的 Optional 是 abstract 的，意味着我可以有子类对象；我大哥的是 final 的，意味着没有子类对象。</li>
<li>我的 Optional 实现了 Serializable 接口，可以序列化；我大哥的没有。</li>
<li>我的一些方法和我大哥的也不尽相同。</li>
</ul>
<p>使用 Optional 除了赋予 null 语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional 迫使你积极思考引用缺失的情况，因为你必须显式地从 Optional 获取引用。</p>
<p>除了 Optional 之外，我还提供了：</p>
<ul>
<li>参数校验</li>
<li>常见的 Object 方法，比如说 Objects.equals、Objects.hashCode，JDK 7 引入的 Objects 类提供同样的方法，当然也是从我这借鉴的灵感。</li>
<li>更强大的比较器</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>首先我来说一下，为什么需要不可变集合。</p>
<ul>
<li>保证线程安全。在并发程序中，使用不可变集合既保证线程的安全性，也大大地增强了并发时的效率（跟并发锁方式相比）。</li>
<li>如果一个对象不需要支持修改操作，不可变的集合将会节省空间和时间的开销。</li>
<li>可以当作一个常量来对待，并且集合中的对象在以后也不会被改变。</li>
</ul>
<p>与 JDK 中提供的不可变集合相比，我提供的 Immutable 才是真正的不可变，我为什么这么说呢？来看下面这个示例。</p>
<p>下面的代码利用 JDK 的 <a href="https://javabetter.cn/common-tool/collections.html"><code>Collections.unmodifiableList(list)</code></a> 得到一个不可修改的集合 unmodifiableList。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line"></span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">unmodifiableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>

<p>运行代码将会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">	at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1060)</span><br><span class="line">	at com.itwanger.guava.NullTest.main(NullTest.java:29)</span><br></pre></td></tr></table></figure>

<p>很好，执行 <code>unmodifiableList.add()</code> 的时候抛出了 UnsupportedOperationException 异常，说明 <code>Collections.unmodifiableList()</code> 返回了一个不可变集合。但真的是这样吗？</p>
<p>你可以把 <code>unmodifiableList.add()</code> 换成 <code>list.add()</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line"></span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">list.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>

<p>再次执行的话，程序并没有报错，并且你会发现 unmodifiableList 中真的多了一个元素。说明什么呢？</p>
<p><code>Collections.unmodifiableList(…)</code> 实现的不是真正的不可变集合，当原始集合被修改后，不可变集合里面的元素也是跟着发生变化。</p>
<p>我就不会犯这种错，来看下面的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = Lists.newArrayList(&quot;雷军&quot;,&quot;乔布斯&quot;);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(stringArrayList);</span><br><span class="line">immutableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>

<p>尝试 <code>immutableList.add()</code> 的时候会抛出 <code>UnsupportedOperationException</code>。我在源码中已经把 <code>add()</code> 方法废弃了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Guaranteed to throw an exception and leave the collection unmodified.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> UnsupportedOperationException always</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@deprecated</span> Unsupported operation.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试 <code>stringArrayList.add()</code> 修改原集合的时候 immutableList 并不会因此而发生改变。</p>
<p>除了不可变集合以外，我还提供了新的集合类型，比如说：</p>
<ul>
<li>Multiset，可以多次添加相等的元素。当把 Multiset 看成普通的 Collection 时，它表现得就像无序的 ArrayList；当把 Multiset 看作 <code>Map&lt;E, Integer&gt;</code> 时，它也提供了符合性能期望的查询操作。</li>
<li>Multimap，可以很容易地把一个键映射到多个值。</li>
<li>BiMap，一种特殊的 Map，可以用 <code>inverse()</code> 反转<br> <code>BiMap&lt;K, V&gt;</code> 的键值映射；保证值是唯一的，因此 <code>values()</code> 返回 Set 而不是普通的 Collection。</li>
</ul>
<h3 id="05、字符串处理"><a href="#05、字符串处理" class="headerlink" title="05、字符串处理"></a>05、字符串处理</h3><p>字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率。</p>
<p>我提供了连接器——Joiner，可以用分隔符把字符串序列连接起来。下面的代码将会返回“雷军; 乔布斯”，你可以使用 <code>useForNull(String)</code> 方法用某个字符串来替换 null，而不像 <code>skipNulls()</code> 方法那样直接忽略 null。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Joiner joiner = Joiner.on(&quot;; &quot;).skipNulls();</span><br><span class="line">return joiner.join(&quot;雷军&quot;, null, &quot;乔布斯&quot;);</span><br></pre></td></tr></table></figure>

<p>我还提供了拆分器—— Splitter，可以按照指定的分隔符把字符串序列进行拆分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Splitter.on(&#x27;,&#x27;)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(&quot;雷军,乔布斯,,   火锅&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="06、缓存"><a href="#06、缓存" class="headerlink" title="06、缓存"></a>06、缓存</h3><p>缓存在很多场景下都是相当有用的。你应该知道，检索一个值的代价很高，尤其是需要不止一次获取值的时候，就应当考虑使用缓存。</p>
<p>我提供的 Cache 和 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，我提供的 Cache 为了限制内存占用，通常都设定为自动回收元素。</p>
<p>如果你愿意消耗一些内存空间来提升速度，你能预料到某些键会被查询一次以上，缓存中存放的数据总量不会超出内存容量，就可以使用 Cache。</p>
<p>来个示例你感受下吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CacheLoader</span> <span class="variable">cacheLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, Animal&gt;() &#123;</span><br><span class="line">        <span class="comment">// 如果找不到元素，会调用这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Animal <span class="title function_">load</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LoadingCache&lt;String, Animal&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 容量</span></span><br><span class="line">        .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 过期时间</span></span><br><span class="line">        .removalListener(<span class="keyword">new</span> <span class="title class_">MyRemovalListener</span>()) <span class="comment">// 失效监听器</span></span><br><span class="line">        .build(cacheLoader); <span class="comment">//</span></span><br><span class="line">    loadingCache.put(<span class="string">&quot;狗&quot;</span>, <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">    loadingCache.put(<span class="string">&quot;猫&quot;</span>, <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;汤姆&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    loadingCache.put(<span class="string">&quot;狼&quot;</span>, <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;灰太狼&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    loadingCache.invalidate(<span class="string">&quot;猫&quot;</span>); <span class="comment">// 手动失效</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> loadingCache.get(<span class="string">&quot;狼&quot;</span>);</span><br><span class="line">    System.out.println(animal);</span><br><span class="line">    Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 狼已经自动过去，获取为 null 值报错</span></span><br><span class="line">    System.out.println(loadingCache.get(<span class="string">&quot;狼&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存移除监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRemovalListener</span> <span class="keyword">implements</span> <span class="title class_">RemovalListener</span>&lt;String, Animal&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(RemovalNotification&lt;String, Animal&gt; notification)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> String.format(<span class="string">&quot;key=%s,value=%s,reason=%s&quot;</span>, notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheLoader 中重写了 load 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 null，其实这样会在没有命中时抛出 CacheLoader returned null for key 异常信息。</p>
<p>MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 onRemoval 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。</p>
<p>LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 put 和 get 方法了。</p>
<h3 id="07、集合工具"><a href="#07、集合工具" class="headerlink" title="07、集合工具"></a>07、集合工具</h3><p><code>com.google.common.collect</code>包下的集合工具：<code>Lists</code>也非常强大。</p>
<h4 id="创建空集合"><a href="#创建空集合" class="headerlink" title="创建空集合"></a>创建空集合</h4><p>有时候，我们想创建一个空集合。这时可以用Lists的<code>newArrayList</code>方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br></pre></td></tr></table></figure>

<h4 id="快速初始化集合"><a href="#快速初始化集合" class="headerlink" title="快速初始化集合"></a>快速初始化集合</h4><p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>如果你想将两个集合做<code>笛卡尔积</code>，Lists的<code>cartesianProduct</code>方法可以帮你实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(4,5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; productList = Lists.cartesianProduct(list1,list2);</span><br><span class="line">System.out.println(productList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]</span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>如果你想将一个<code>大集合</code>分成若干个<code>小集合</code>，可以使用Lists的<code>partition</code>方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(list, 2);</span><br><span class="line">System.out.println(partitionList);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[1, 2], [3, 4], [5]]</span><br></pre></td></tr></table></figure>

<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p>
<p>这个是我最喜欢的方法之一，经常在项目中使用。</p>
<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p>
<h4 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h4><p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的 <code>transform</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class="line">List&lt;String&gt; transformList = Lists.transform(list, x -&gt; x.toUpperCase());</span><br><span class="line">System.out.println(transformList);</span><br></pre></td></tr></table></figure>

<p>将小写字母转换成了大写字母。</p>
<h4 id="颠倒顺序"><a href="#颠倒顺序" class="headerlink" title="颠倒顺序"></a>颠倒顺序</h4><p>Lists的有颠倒顺序的方法<code>reverse</code>。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(3, 1, 2);</span><br><span class="line">List&lt;Integer&gt; reverseList = Lists.reverse(list);</span><br><span class="line">System.out.println(reverseList);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[2, 1, 3]</span><br></pre></td></tr></table></figure>

<p>list的原始顺序是312，使用<code>reverse</code>方法颠倒顺序之后，变成了213。</p>
<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的小伙伴，可以仔细研究一下。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/guava-4b962b06-a626-4707-9fe9-f5729536d9c5.jpg"></p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>上面介绍了我认为最常用的功能，作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的）。引入到你的项目后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。</p>
]]></content>
      <categories>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>常用工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>Hutool:国产良心工具包，让你的代码更酸爽</title>
    <url>/article/112215.html</url>
    <content><![CDATA[<h1 id="Hutool工具类库"><a href="#Hutool工具类库" class="headerlink" title="Hutool工具类库"></a>Hutool工具类库</h1><p>读者群里有个小伙伴感慨说，“Hutool 这款开源类库太厉害了，基本上该有该的工具类，它里面都有。”讲真的，我平常工作中也经常用 Hutool，它确实可以帮助我们简化每一行代码，使 Java 拥有函数式语言般的优雅，让 Java 语言变得“甜甜的”。</p>
<p>Hutool 的作者在<a href="https://hutool.cn/">官网</a>上说，Hutool 是 Hu+tool 的自造词（好像不用说，我们也能猜得到），“Hu”用来致敬他的“前任”公司，“tool”就是工具的意思，谐音就有意思了，“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”（一个开源类库，上升到了哲学的高度，作者厉害了）。</p>
<p>看了一下开发团队的一个成员介绍，一个 Java 后端工具的作者竟然爱前端、爱数码，爱美女，嗯嗯嗯，确实“难得糊涂”（手动狗头）。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-01.png"></p>
<p>废话就说到这，来吧，实操走起！</p>
<h3 id="引入-Hutool"><a href="#引入-Hutool" class="headerlink" title="引入 Hutool"></a>引入 Hutool</h3><p>Maven 项目只需要在 pom.xml 文件中添加以下依赖即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>Hutool 的设计思想是尽量减少重复的定义，让项目中的 util 包尽量少。一个好的轮子可以在很大程度上避免“复制粘贴”，从而节省我们开发人员对项目中公用类库和公用工具方法的封装时间。同时呢，成熟的开源库也可以最大限度的避免封装不完善带来的 bug。</p>
<p>就像作者在官网上说的那样：</p>
<ul>
<li>以前，我们打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客 -&gt; 复制粘贴 -&gt; 改改，变得好用些</li>
<li>有了 Hutool 以后呢，引入 Hutool -&gt; 直接 <code>SecureUtil.md5()</code></li>
</ul>
<p>Hutool 对不仅对 JDK 底层的文件、流、加密解密、转码、正则、线程、XML等做了封装，还提供了以下这些组件：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-02.png"></p>
<p>非常多，非常全面，鉴于此，我只挑选一些我喜欢的来介绍下（偷偷地告诉你，我就是想偷懒）。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换在 Java 开发中很常见，尤其是从 HttpRequest 中获取参数的时候，前端传递的是整型，但后端只能先获取到字符串，然后再调用 <code>parseXXX()</code> 方法进行转换，还要加上判空，很繁琐。</p>
<p>Hutool 的 Convert 类可以简化这个操作，可以将任意可能的类型转换为指定类型，同时第二个参数 defaultValue 可用于在转换失败时返回一个默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="string">&quot;10&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">paramInt</span> <span class="operator">=</span> Convert.toInt(param);</span><br><span class="line"><span class="type">int</span> <span class="variable">paramIntDefault</span> <span class="operator">=</span> Convert.toInt(param, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>把字符串转换成日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2020年09月29日&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Convert.toDate(dateStr);</span><br></pre></td></tr></table></figure>

<p>把字符串转成 Unicode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">unicodeStr</span> <span class="operator">=</span> <span class="string">&quot;马斯克&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">unicode</span> <span class="operator">=</span> Convert.strToUnicode(unicodeStr);</span><br></pre></td></tr></table></figure>

<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p>JDK 自带的 Date 和 Calendar 不太好用，Hutool 封装的 DateUtil 用起来就舒服多了！</p>
<p>获取当前日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> DateUtil.date();</span><br></pre></td></tr></table></figure>

<p><code>DateUtil.date()</code> 返回的其实是 DateTime，它继承自 Date 对象，重写了 <code>toString()</code> 方法，返回 <code>yyyy-MM-dd HH:mm:ss</code> 格式的字符串。</p>
<p>有些小伙伴是不是想看看我写这篇文章的时间，输出一下给大家看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(date);// 2020-09-29 04:28:02</span><br></pre></td></tr></table></figure>

<p>字符串转日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2020-09-29&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> DateUtil.parse(dateStr);</span><br></pre></td></tr></table></figure>

<p><code>DateUtil.parse()</code> 会自动识别一些常用的格式，比如说：</p>
<ul>
<li>yyyy-MM-dd HH:mm:ss</li>
<li>yyyy-MM-dd</li>
<li>HH:mm:ss</li>
<li>yyyy-MM-dd HH:mm</li>
<li>yyyy-MM-dd HH:mm:ss.SSS</li>
</ul>
<p>还可以识别带中文的：</p>
<ul>
<li>年月日时分秒</li>
</ul>
<p>格式化时间差：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStr1</span> <span class="operator">=</span> <span class="string">&quot;2020-09-29 22:33:23&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> DateUtil.parse(dateStr1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr2</span> <span class="operator">=</span> <span class="string">&quot;2020-10-01 23:34:27&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> DateUtil.parse(dateStr2);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">betweenDay</span> <span class="operator">=</span> DateUtil.between(date1, date2, DateUnit.MS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：2天1小时1分4秒</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formatBetween</span> <span class="operator">=</span> DateUtil.formatBetween(betweenDay, BetweenFormater.Level.SECOND);</span><br></pre></td></tr></table></figure>

<p>星座和属相：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 射手座</span></span><br><span class="line"><span class="type">String</span> <span class="variable">zodiac</span> <span class="operator">=</span> DateUtil.getZodiac(Month.DECEMBER.getValue(), <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 蛇</span></span><br><span class="line"><span class="type">String</span> <span class="variable">chineseZodiac</span> <span class="operator">=</span> DateUtil.getChineseZodiac(<span class="number">1989</span>);</span><br></pre></td></tr></table></figure>

<h3 id="IO-流相关"><a href="#IO-流相关" class="headerlink" title="IO 流相关"></a>IO 流相关</h3><p><a href="https://javabetter.cn/io/shangtou.html">IO 操作包括读和写</a>，应用的场景主要包括网络操作和文件操作，原生的 Java 类库区分<a href="https://javabetter.cn/io/reader-writer.html">字符流</a>和<a href="https://javabetter.cn/io/stream.html">字节流</a>，字节流 InputStream 和 OutputStream 就有很多很多种，使用起来让人头皮发麻。</p>
<p>Hutool 封装了流操作工具类 IoUtil、文件读写操作工具类 FileUtil、文件类型判断工具类 FileTypeUtil 等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> FileUtil.getInputStream(<span class="string">&quot;hutool/origin.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> FileUtil.getOutputStream(<span class="string">&quot;hutool/to.txt&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">copySize</span> <span class="operator">=</span> IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>

<p>在 IO 操作中，文件的操作相对来说是比较复杂的，但使用频率也很高，几乎所有的项目中都躺着一个叫 FileUtil 或者 FileUtils 的工具类。Hutool 的 FileUtil 类包含以下几类操作：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>顺带说说 classpath。</p>
<p>在实际编码当中，我们通常需要从某些文件里面读取一些数据，比如配置文件、文本文件、图片等等，那这些文件通常放在什么位置呢？</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-03.png"></p>
<p>放在项目结构图中的 resources 目录下，当项目编译后，会出现在 classes 目录下。对应磁盘上的目录如下图所示：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-04.png"></p>
<p>当我们要读取文件的时候，我是不建议使用绝对路径的，因为操作系统不一样的话，文件的路径标识符也是不一样的。最好使用相对路径。</p>
<p>假设在 <code>src/resources</code> 下放了一个文件 origin.txt，文件的路径参数如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;origin.txt&quot;)</span><br></pre></td></tr></table></figure>

<p>假设文件放在 <code>src/resources/hutool</code> 目录下，则路径参数改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;hutool/origin.txt&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="字符串工具"><a href="#字符串工具" class="headerlink" title="字符串工具"></a>字符串工具</h3><p>Hutool 封装的字符串工具类 StrUtil 和 Apache Commons Lang 包中的 StringUtils 类似，作者认为优势在于 Str 比 String 短，尽管我不觉得。不过，我倒是挺喜欢其中的一个方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#125;，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索&#123;&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> StrUtil.format(template, <span class="string">&quot;马斯克&quot;</span>, <span class="string">&quot;马斯克&quot;</span>);</span><br><span class="line"><span class="comment">// 马斯克，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索马斯克</span></span><br></pre></td></tr></table></figure>

<h3 id="反射工具"><a href="#反射工具" class="headerlink" title="反射工具"></a>反射工具</h3><p>反射机制可以让 Java 变得更加灵活，因此在某些情况下，反射可以做到事半功倍的效果。Hutool 封装的反射工具 ReflectUtil 包括：</p>
<ul>
<li>获取构造方法</li>
<li>获取字段</li>
<li>获取字段值</li>
<li>获取方法</li>
<li>执行方法（对象方法和静态方法）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itwanger.hutool.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ReflectUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是马斯克&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 构建对象</span></span><br><span class="line">        <span class="type">ReflectDemo</span> <span class="variable">reflectDemo</span> <span class="operator">=</span> ReflectUtil.newInstance(ReflectDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法</span></span><br><span class="line">        Constructor[] constructors = ReflectUtil.getConstructors(ReflectDemo.class);</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ReflectUtil.getField(ReflectDemo.class, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">        field.setInt(reflectDemo, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 获取字段值</span></span><br><span class="line">        System.out.println(ReflectUtil.getFieldValue(reflectDemo, field));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有方法</span></span><br><span class="line">        Method[] methods = ReflectUtil.getMethods(ReflectDemo.class);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectUtil.getMethod(ReflectDemo.class, <span class="string">&quot;print&quot;</span>);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        ReflectUtil.invoke(reflectDemo, <span class="string">&quot;print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="压缩工具"><a href="#压缩工具" class="headerlink" title="压缩工具"></a>压缩工具</h3><p>在 Java 中，对文件、文件夹打包压缩是一件很繁琐的事情，Hutool 封装的 ZipUtil 针对 java.util.zip 包做了优化，可以使用一个方法搞定压缩和解压，并且自动处理文件和目录的问题，不再需要用户判断，大大简化的压缩解压的复杂度。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZipUtil.zip(&quot;hutool&quot;, &quot;hutool.zip&quot;);</span><br><span class="line">File unzip = ZipUtil.unzip(&quot;hutool.zip&quot;, &quot;hutoolzip&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="身份证工具"><a href="#身份证工具" class="headerlink" title="身份证工具"></a>身份证工具</h3><p>Hutool 封装的 IdcardUtil 可以用来对身份证进行验证，支持大陆 15 位、18 位身份证，港澳台 10 位身份证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ID_18</span> <span class="operator">=</span> <span class="string">&quot;321083197812162119&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ID_15</span> <span class="operator">=</span> <span class="string">&quot;150102880730303&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> IdcardUtil.isValidCard(ID_18);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">valid15</span> <span class="operator">=</span> IdcardUtil.isValidCard(ID_15);</span><br></pre></td></tr></table></figure>

<h3 id="扩展-HashMap"><a href="#扩展-HashMap" class="headerlink" title="扩展 HashMap"></a>扩展 HashMap</h3><p>Java 中的 HashMap 是强类型的，而 Hutool 封装的 Dict 对键的类型要求没那么严格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dict</span> <span class="variable">dict</span> <span class="operator">=</span> Dict.create()</span><br><span class="line">        .set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">        .set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;马斯克&quot;</span>)</span><br><span class="line">        .set(<span class="string">&quot;birthday&quot;</span>, DateTime.now());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dict.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dict.getStr(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="控制台打印"><a href="#控制台打印" class="headerlink" title="控制台打印"></a>控制台打印</h3><p>本地编码的过程中，经常需要使用 <code>System.out</code> 打印结果，但是往往一些复杂的对象不支持直接打印，比如说数组，需要调用 <code>Arrays.toString</code>。Hutool 封装的 Console 类借鉴了 JavaScript 中的 <code>console.log()</code>，使得打印变成了一个非常便捷的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印字符串</span></span><br><span class="line">        Console.log(<span class="string">&quot;马斯克，一枚有趣的程序员&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印字符串模板</span></span><br><span class="line">        Console.log(<span class="string">&quot;洛阳是&#123;&#125;朝古都&quot;</span>,<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        Console.log(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段验证器"><a href="#字段验证器" class="headerlink" title="字段验证器"></a>字段验证器</h3><p>做 Web 开发的时候，后端通常需要对表单提交过来的数据进行验证。Hutool 封装的 Validator 可以进行很多有效的条件验证：</p>
<ul>
<li>是不是邮箱</li>
<li>是不是 IP V4、V6</li>
<li>是不是电话号码</li>
<li>等等</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-05.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Validator.isEmail(&quot;马斯克&quot;);</span><br><span class="line">Validator.isMobile(&quot;itwanger.com&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="双向查找-Map"><a href="#双向查找-Map" class="headerlink" title="双向查找 Map"></a>双向查找 Map</h3><p><a href="https://javabetter.cn/common-tool/guava.html">Guava</a> 中提供了一种特殊的 Map 结构，叫做 BiMap，实现了一种双向查找的功能，可以根据 key 查找 value，也可以根据 value 查找 key，Hutool 也提供这种 Map 结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = new BiMap&lt;&gt;(new HashMap&lt;&gt;());</span><br><span class="line">biMap.put(&quot;wanger&quot;, &quot;马斯克&quot;);</span><br><span class="line">biMap.put(&quot;wangsan&quot;, &quot;沉默王三&quot;);</span><br><span class="line"></span><br><span class="line">// get value by key</span><br><span class="line">biMap.get(&quot;wanger&quot;);</span><br><span class="line">biMap.get(&quot;wangsan&quot;);</span><br><span class="line"></span><br><span class="line">// get key by value</span><br><span class="line">biMap.getKey(&quot;马斯克&quot;);</span><br><span class="line">biMap.getKey(&quot;沉默王三&quot;);</span><br></pre></td></tr></table></figure>

<p>在实际的开发工作中，其实我更倾向于使用 Guava 的 BiMap，而不是 Hutool 的。这里提一下，主要是我发现了 Hutool 在线文档上的一处错误，提了个 issue（从中可以看出我一颗一丝不苟的心和一双清澈明亮的大眼睛啊）。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-06.png"></p>
<h3 id="图片工具"><a href="#图片工具" class="headerlink" title="图片工具"></a>图片工具</h3><p>Hutool 封装的 ImgUtil 可以对图片进行缩放、裁剪、转为黑白、加水印等操作。</p>
<p>缩放图片：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ImgUtil.scale(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_small.jpg&quot;),</span><br><span class="line">        0.5f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>裁剪图片：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ImgUtil.cut(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_cut.jpg&quot;),</span><br><span class="line">        new Rectangle(200, 200, 100, 100)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>添加水印：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ImgUtil.pressText(//</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_logo.jpg&quot;),</span><br><span class="line">        &quot;马斯克&quot;, Color.WHITE,</span><br><span class="line">        new Font(&quot;黑体&quot;, Font.BOLD, 100),</span><br><span class="line">        0,</span><br><span class="line">        0,</span><br><span class="line">        0.8f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>趁机让大家欣赏一下二哥帅气的真容。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/hutool-07.png"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote>
<p>众所周知，Java 中广泛应用的配置文件 Properties 存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，就必须借助 IDE 相关插件才能转为 Unicode 符号，而这种反人类的符号在命令行下根本没法看。</p>
</blockquote>
<p>于是，Hutool 的 Setting 运用而生。Setting 除了兼容 Properties 文件格式外，还提供了一些特有功能，这些功能包括：</p>
<ul>
<li>各种编码方式支持</li>
<li>变量支持</li>
<li>分组支持</li>
</ul>
<p>先整个配置文件 example.setting，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=马斯克</span><br><span class="line">age=18</span><br></pre></td></tr></table></figure>

<p>再来读取和更新配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SettingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SETTING</span> <span class="operator">=</span> <span class="string">&quot;hutool/example.setting&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 Setting</span></span><br><span class="line">        <span class="type">Setting</span> <span class="variable">setting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Setting</span>(SETTING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        setting.getStr(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;马斯克&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在配置文件变更时自动加载</span></span><br><span class="line">        setting.autoLoad(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代码方式增加键值对</span></span><br><span class="line">        setting.set(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;2020年09月29日&quot;</span>);</span><br><span class="line">        setting.store(SETTING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h3><p>Hutool 封装的日志工厂 LogFactory 兼容了各大日志框架，使用起来也非常简便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;难得糊涂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过 <code>LogFactory.get()</code> 自动识别引入的日志框架，从而创建对应日志框架的门面 Log 对象，然后调用 <code>debug()</code>、<code>info()</code> 等方法输出日志。</p>
<p>如果不想创建 Log 对象的话，可以使用 StaticLog，顾名思义，一个提供了静态方法的日志类。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">StaticLog.info(&quot;爽啊 &#123;&#125;.&quot;, &quot;马斯克的文章&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="缓存工具"><a href="#缓存工具" class="headerlink" title="缓存工具"></a>缓存工具</h3><p>CacheUtil 是 Hutool 封装的创建缓存的快捷工具类，可以创建不同的缓存对象：</p>
<ul>
<li>FIFOCache：先入先出，元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; fifoCache = CacheUtil.newFIFOCache(3);</span><br><span class="line">fifoCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">fifoCache.put(&quot;key2&quot;, &quot;马斯克&quot;);</span><br><span class="line">fifoCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">fifoCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line"></span><br><span class="line">// 大小为 3，所以 key3 放入后 key1 被清除</span><br><span class="line">String value1 = fifoCache.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>LFUCache，最少使用，根据使用次数来判定对象是否被持续缓存，当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问的对象并将其他对象的访问数减去这个最少访问数，以便新对象进入后可以公平计数。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lfuCache = CacheUtil.newLFUCache(3);</span><br><span class="line"></span><br><span class="line">lfuCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">// 使用次数+1</span><br><span class="line">lfuCache.get(&quot;key1&quot;);</span><br><span class="line">lfuCache.put(&quot;key2&quot;, &quot;马斯克&quot;);</span><br><span class="line">lfuCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">lfuCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line"></span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最少使用的将被移除（2,3被移除）</span><br><span class="line">String value2 = lfuCache.get(&quot;key2&quot;);</span><br><span class="line">String value3 = lfuCache.get(&quot;key3&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>LRUCache，最近最久未使用，根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lruCache = CacheUtil.newLRUCache(3);</span><br><span class="line"></span><br><span class="line">lruCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">lruCache.put(&quot;key2&quot;, &quot;马斯克&quot;);</span><br><span class="line">lruCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">// 使用时间近了</span><br><span class="line">lruCache.get(&quot;key1&quot;);</span><br><span class="line">lruCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line"></span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最久使用的将被移除（2）</span><br><span class="line">String value2 = lruCache.get(&quot;key2&quot;);</span><br><span class="line">System.out.println(value2);</span><br></pre></td></tr></table></figure>

<h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><p>加密分为三种：</p>
<ul>
<li>对称加密（symmetric），例如：AES、DES 等</li>
<li>非对称加密（asymmetric），例如：RSA、DSA 等</li>
<li>摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC 等</li>
</ul>
<p>Hutool 针对这三种情况都做了封装：</p>
<ul>
<li>对称加密 SymmetricCrypto</li>
<li>非对称加密 AsymmetricCrypto</li>
<li>摘要加密 Digester</li>
</ul>
<p>快速加密工具类 SecureUtil 有以下这些方法：</p>
<p>1）对称加密</p>
<ul>
<li>SecureUtil.aes</li>
<li>SecureUtil.des</li>
</ul>
<p>2）非对称加密</p>
<ul>
<li>SecureUtil.rsa</li>
<li>SecureUtil.dsa</li>
</ul>
<p>3）摘要加密</p>
<ul>
<li>SecureUtil.md5</li>
<li>SecureUtil.sha1</li>
<li>SecureUtil.hmac</li>
<li>SecureUtil.hmacMd5</li>
<li>SecureUtil.hmacSha1</li>
</ul>
<p>只写一个简单的例子作为参考：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureUtilDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AES</span> <span class="variable">aes</span> <span class="operator">=</span> SecureUtil.aes();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encry</span> <span class="operator">=</span> aes.encryptHex(<span class="string">&quot;马斯克&quot;</span>);</span><br><span class="line">        System.out.println(encry);</span><br><span class="line">        <span class="type">String</span> <span class="variable">oo</span> <span class="operator">=</span> aes.decryptStr(encry);</span><br><span class="line">        System.out.println(oo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、其他类库"><a href="#18、其他类库" class="headerlink" title="18、其他类库"></a>18、其他类库</h3><p>Hutool 中的类库还有很多，尤其是一些对第三方类库的进一步封装，比如邮件工具 MailUtil，二维码工具 QrCodeUtil，Emoji 工具 EmojiUtil，小伙伴们可以参考 Hutool 的官方文档：<a href="https://www.hutool.cn/">https://www.hutool.cn/</a></p>
<p>项目源码地址：<a href="https://github.com/looly/hutool">https://github.com/looly/hutool</a></p>
]]></content>
      <categories>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>常用工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Java工具类：IPUtil、CollectionUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils</title>
    <url>/article/112220.html</url>
    <content><![CDATA[<h1 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h1><p>除了我们前面提到的 Java 原生工具类，比如说 <a href="https://javabetter.cn/common-tool/arrays.html">Arrays</a>、<a href="https://javabetter.cn/common-tool/Objects.html">Objects</a>、<a href="https://javabetter.cn/common-tool/collections.html">Collections</a>、<a href="https://javabetter.cn/common-tool/scanner.html">Scanner</a> 等，还有一些第三方的工具类，比如说 <a href="https://javabetter.cn/common-tool/hutool.html">Hutool</a>、<a href="https://javabetter.cn/common-tool/guava.html">Guava</a> 等，以及我们今天介绍的 IpUtil、CollectionUtils、StringUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils 等等，在很大程度上能够提高我们的生产效率。</p>
<p>当然了，如果能好好看一下它们的源码，对技术功底的提升，也是有很大帮助的。</p>
<h3 id="IpUtil：获取本机-Ip"><a href="#IpUtil：获取本机-Ip" class="headerlink" title="IpUtil：获取本机 Ip"></a>IpUtil：获取本机 Ip</h3><p>获取本机 IP 算是比较常见的一个需求场景了，比如业务报警，可能就会带上出问题的机器 IP，方便直接上去看日志定位问题，那么问题来了，如何获取机器 IP 呢？</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>如何获取机器 IP？如果了解 InetAddress 这个工具类，就很容易写出一个简单的工具类，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalIP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现有问题么？</p>
<p>当然没问题，拿我本机和阿里服务器执行一下，并没有问题如实的输出了预期的 IP</p>
<p>本机执行后截图如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/utils-20230330093633.png"></p>
<p>阿里云机器执行后截图如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/utils-20230330095801.png"></p>
<h4 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h4><p>做一点简单的改动，获取 IPV4 的地址，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalIpByNetcard</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 枚举所有的网络接口</span></span><br><span class="line">        <span class="keyword">for</span> (Enumeration&lt;NetworkInterface&gt; e = NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">            <span class="comment">// 获取当前网络接口</span></span><br><span class="line">            <span class="type">NetworkInterface</span> <span class="variable">item</span> <span class="operator">=</span> e.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前网络接口的所有地址</span></span><br><span class="line">            <span class="keyword">for</span> (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                <span class="comment">// 忽略回环地址和未启用的网络接口</span></span><br><span class="line">                <span class="keyword">if</span> (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前地址是 IPv4 地址，则返回其字符串表示</span></span><br><span class="line">                <span class="keyword">if</span> (address.getAddress() <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">                    <span class="type">Inet4Address</span> <span class="variable">inet4Address</span> <span class="operator">=</span> (Inet4Address) address.getAddress();</span><br><span class="line">                    <span class="keyword">return</span> inet4Address.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到任何 IPv4 地址，则返回本地主机地址</span></span><br><span class="line">        <span class="keyword">return</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException | UnknownHostException e) &#123;</span><br><span class="line">        <span class="comment">// 抛出运行时异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这段代码只返回本机的 IPv4 地址，并且只返回第一个符合条件的地址。如果本机有多个网络接口或者每个接口有多个地址，则可能无法返回预期的地址。此外，如果找不到任何 IPv4 地址，则会返回本地主机地址。</p>
<p>再次测试，输出如下</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/utils-20230330100334.png"></p>
<h4 id="完整工具类"><a href="#完整工具类" class="headerlink" title="完整工具类"></a>完整工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IPUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_IP</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接根据第一个网卡地址作为其内网ipv4地址，避免返回 127.0.0.1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第一个符合条件的内网 IPv4 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalIpByNetcard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 枚举所有的网络接口</span></span><br><span class="line">            <span class="keyword">for</span> (Enumeration&lt;NetworkInterface&gt; e = NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">                <span class="comment">// 获取当前网络接口</span></span><br><span class="line">                <span class="type">NetworkInterface</span> <span class="variable">item</span> <span class="operator">=</span> e.nextElement();</span><br><span class="line">                <span class="comment">// 遍历当前网络接口的所有地址</span></span><br><span class="line">                <span class="keyword">for</span> (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                    <span class="comment">// 忽略回环地址和未启用的网络接口</span></span><br><span class="line">                    <span class="keyword">if</span> (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果当前地址是 IPv4 地址，则返回其字符串表示</span></span><br><span class="line">                    <span class="keyword">if</span> (address.getAddress() <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">                        <span class="type">Inet4Address</span> <span class="variable">inet4Address</span> <span class="operator">=</span> (Inet4Address) address.getAddress();</span><br><span class="line">                        <span class="keyword">return</span> inet4Address.getHostAddress();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有找到符合条件的地址，则返回本地主机地址</span></span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException | UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本地主机地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 本地主机地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalIP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPUtil 类中定义了两个方法，分别是 <code>getLocalIpByNetcard()</code> 和 <code>getLocalIP()</code>。前者是获取本机的内网 IPv4 地址，避免了返回 127.0.0.1 的问题。后者是获取本地主机地址，如果本机有多个 IP 地址，则可能返回其中的任意一个。</p>
<h3 id="MDC：一个线程安全的参数传递工具类"><a href="#MDC：一个线程安全的参数传递工具类" class="headerlink" title="MDC：一个线程安全的参数传递工具类"></a>MDC：一个线程安全的参数传递工具类</h3><p><code>MDC</code> 是 <a href="https://javabetter.cn/gongju/slf4j.html"><code>org.slf4j</code></a> 包下的一个类，它的全称是 Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>
<p>MDC 的底层是用了 <a href="https://javabetter.cn/thread/ThreadLocal.html"><code>ThreadLocal</code></a> 来保存数据的。</p>
<p>我们可以用它传递参数。</p>
<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source 等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>
<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p>
<p>第一步，定义一个 LogFilter 拦截所有接口请求，在 MDC 中设置 traceId：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        MdcUtil.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;记录请求日志&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">&quot;记录响应日志&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC 中获取当前请求的 traceId，然后设置到 header 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        request.getHeaders().set(<span class="string">&quot;traceId&quot;</span>, MdcUtil.get());</span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，定义配置类，配置上面定义的<code>RestTemplateInterceptor</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplateInterceptor <span class="title function_">restTemplateInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplateInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 MdcUtil 其实是利用 MDC 工具在 ThreadLocal 中存储和获取 traceId</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdcUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRACE_ID</span> <span class="operator">=</span> <span class="string">&quot;TRACE_ID&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MDC.get(TRACE_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        MDC.put(TRACE_ID, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个例子中没有演示 MdcUtil 类的 add 方法具体调的地方，我们可以在 filter 中执行接口方法之前，生成 traceId，调用 MdcUtil 类的 add 方法添加到 MDC 中，然后在同一个请求的其他地方就能通过 MdcUtil 类的 get 方法获取到该 traceId。</p>
<p>能使用 MDC 保存 traceId 等参数的根本原因是，用户请求到应用服务器，Tomcat 会从线程池中分配一个线程去处理该请求。</p>
<p>那么该请求的整个过程中，保存到 MDC 的 ThreadLocal 中的参数，也是该线程独享的，所以不会有线程安全问题。</p>
<h3 id="ClassUtils"><a href="#ClassUtils" class="headerlink" title="ClassUtils"></a>ClassUtils</h3><p>spring 的<code>org.springframework.util</code>包下的<code>ClassUtils</code>类，它里面有很多让我们惊喜的功能。</p>
<p>它里面包含了类和对象相关的很多非常实用的方法。</p>
<h4 id="获取对象的所有接口"><a href="#获取对象的所有接口" class="headerlink" title="获取对象的所有接口"></a>获取对象的所有接口</h4><p>如果你想获取某个对象的所有接口，可以使用 ClassUtils 的<code>getAllInterfaces</code>方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br></pre></td></tr></table></figure>

<h4 id="获取某个类的包名"><a href="#获取某个类的包名" class="headerlink" title="获取某个类的包名"></a>获取某个类的包名</h4><p>如果你想获取某个类的包名，可以使用 ClassUtils 的<code>getPackageName</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">String packageName = ClassUtils.getPackageName(User.class);</span><br><span class="line">System.out.println(packageName);</span><br></pre></td></tr></table></figure>

<h4 id="判断某个类是否内部类"><a href="#判断某个类是否内部类" class="headerlink" title="判断某个类是否内部类"></a>判断某个类是否内部类</h4><p>如果你想判断某个类是否内部类，可以使用 ClassUtils 的<code>isInnerClass</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">System.out.println(ClassUtils.isInnerClass(User.class));</span><br></pre></td></tr></table></figure>

<h4 id="判断对象是否代理对象"><a href="#判断对象是否代理对象" class="headerlink" title="判断对象是否代理对象"></a>判断对象是否代理对象</h4><p>如果你想判断对象是否代理对象，可以使用 ClassUtils 的<code>isCglibProxy</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">System.out.println(ClassUtils.isCglibProxy(new User()));</span><br></pre></td></tr></table></figure>

<p>ClassUtils 还有很多有用的方法，等待着你去发掘。感兴趣的小伙伴，可以看看下面的内容：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/utils-c58920ac-cf04-4d95-ad29-90339a086569.jpg"></p>
<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><p>Spring 给我们提供了一个<code>JavaBean</code>的工具类，它在<code>org.springframework.beans</code>包下面，它的名字叫做：<code>BeanUtils</code>。</p>
<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p>
<h4 id="拷贝对象的属性"><a href="#拷贝对象的属性" class="headerlink" title="拷贝对象的属性"></a>拷贝对象的属性</h4><p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用 BeanUtils 的<code>copyProperties</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">User user1 = new User();</span><br><span class="line">user1.setId(1L);</span><br><span class="line">user1.setName(&quot;马斯克&quot;);</span><br><span class="line">user1.setAddress(&quot;中国&quot;);</span><br><span class="line"></span><br><span class="line">User user2 = new User();</span><br><span class="line">BeanUtils.copyProperties(user1, user2);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<h4 id="实例化某个类"><a href="#实例化某个类" class="headerlink" title="实例化某个类"></a>实例化某个类</h4><p>如果你想通过反射实例化一个类的对象，可以使用 BeanUtils 的<code>instantiateClass</code>方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtils.instantiateClass(User.class);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<h4 id="获取指定类的指定方法"><a href="#获取指定类的指定方法" class="headerlink" title="获取指定类的指定方法"></a>获取指定类的指定方法</h4><p>如果你想获取某个类的指定方法，可以使用 BeanUtils 的<code>findDeclaredMethod</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(declaredMethod.getName());</span><br></pre></td></tr></table></figure>

<h4 id="获取指定方法的参数"><a href="#获取指定方法的参数" class="headerlink" title="获取指定方法的参数"></a>获取指定方法的参数</h4><p>如果你想获取某个方法的参数，可以使用 BeanUtils 的<code>findPropertyForMethod</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);</span><br><span class="line">System.out.println(propertyForMethod.getName());</span><br></pre></td></tr></table></figure>

<p>如果你对 BeanUtils 比较感兴趣，可以看看下面内容：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/common-tool/utils-629ecd75-259b-46aa-b1dd-82606cfc92ee.jpg"></p>
<h3 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h3><p>有时候，我们需要在项目中使用<code>反射</code>功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p>
<p>好消息是 Spring 给我们提供了一个<code>ReflectionUtils</code>工具，它在<code>org.springframework.util</code>包下面。</p>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><p>如果你想获取某个类的某个方法，可以使用 ReflectionUtils 类的<code>findMethod</code>方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionUtils.findMethod(User.class, <span class="string">&quot;getId&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h4><p>如果你想获取某个类的某个字段，可以使用 ReflectionUtils 类的<code>findField</code>方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ReflectionUtils.findField(User.class, <span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><p>如果你想通过反射调用某个方法，传递参数，可以使用 ReflectionUtils 类的<code>invokeMethod</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);</span><br></pre></td></tr></table></figure>

<h4 id="判断字段是否常量"><a href="#判断字段是否常量" class="headerlink" title="判断字段是否常量"></a>判断字段是否常量</h4><p>如果你想判断某个字段是否常量，可以使用 ReflectionUtils 类的<code>isPublicStaticFinal</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Field field = ReflectionUtils.findField(User.class, &quot;id&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isPublicStaticFinal(field));</span><br></pre></td></tr></table></figure>

<h4 id="判断是否-equals-方法"><a href="#判断是否-equals-方法" class="headerlink" title="判断是否 equals 方法"></a>判断是否 equals 方法</h4><p>如果你想判断某个方法是否 equals 方法，可以使用 ReflectionUtils 类的<code>isEqualsMethod</code>方法。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Method method = ReflectionUtils.findMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isEqualsMethod(method));</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java核心</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>最新伊朗《顶级域名》出炉，免费注册 😍，强烈推荐，抢完为止！</title>
    <url>/article/112250.html</url>
    <content><![CDATA[<p>本次域名是<code>顶级域名</code>, 强烈推荐 ！！！</p>
<p>本次域名提供了后缀为 <code> .ir</code> 免费域名。</p>
<p>关键是可以托管到 <code>cloudflare</code> ，实在是太香啦！</p>
<p>本次注册<code>暂时免费 1 年</code>。</p>
<h1 id="进入网站"><a href="#进入网站" class="headerlink" title="进入网站"></a>进入网站</h1><blockquote>
<p><a href="http://www.parsdata.com/en-US/free-domain"><code>点击注册</code></a> 抓紧时间，先到先得 👈👈👈</p>
</blockquote>
<p>登录注册，话不多说。</p>
<p><img src="https://img2.funning.top/file/e6e2d14001da78f58afcb.png" alt="登录注册"></p>
<p>登录进去默认是波斯文，不懂的可以翻译为英文。</p>
<p><img src="https://img2.funning.top/file/e5e9106696fc69d1c42de.png" alt="首页"></p>
<h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><ol>
<li><p>单击控制面板右侧的<code>Domain &amp; Host</code>。通过进入域和托管页面，单击“域注册”图标。</p>
<p><img src="https://img2.funning.top/file/534d8c6b5c12722df944f.png"></p>
</li>
<li><p>只选择 <code>.ir</code> 后缀的，因为只有这个是免费的。</p>
<p><img src="https://img2.funning.top/file/4448a2da504128382a4b4.png"></p>
</li>
<li><p>来到这一步，如果看到状态是 <code>available</code> ，则说明此域名是可以正常注册的。再点击继续。</p>
<p><img src="https://img2.funning.top/file/bdba22c617058dfb7764a.png"></p>
</li>
<li><p>输入优惠码，优惠码在首页，文章下面点的位置。</p>
<p><img src="https://img2.funning.top/file/bdba22c617058dfb7764a.png"></p>
<blockquote>
<p>如果这个优惠码名额没有被抢光，那订单价格会直接变成 <code>0 Rls</code> 。</p>
<p>如果被抢光了，也不用着急，优惠码每天或不定时的更新，小伙伴们最好是看准伊朗时间早一点来到网站，随时关注着，这样机会大一点。</p>
</blockquote>
</li>
<li><p>如果submit 优惠码可以使用，那咱们接着下面的步骤。这里信息需要真实填写，如果未填写国家&#x2F;地区代码字段，则不会通过。</p>
<blockquote>
<p>这里的 National ID 指的就是身份证ID</p>
</blockquote>
<p><img src="https://img2.funning.top/file/9b246fcb994711c85d06e.png"></p>
</li>
<li><p>填写好后，来到这个页面，可以填写 <code>cloudflare 的 dns</code></p>
<p><img src="https://img2.funning.top/file/aa70463f7c12349e0a463.png"></p>
</li>
<li><p>点击 finish 完成域名的注册。</p>
<p><img src="https://img2.funning.top/file/d9bb2703fd8d7afa2ae8d.png"></p>
</li>
<li><p>最后来到这里，就说明注册好了，但是还需要耐心等待 NIC 的审核。</p>
<p><img src="https://img2.funning.top/file/1aa0460237d2db6622b6d.png"></p>
</li>
</ol>
<h1 id="额外服务"><a href="#额外服务" class="headerlink" title="额外服务"></a>额外服务</h1><blockquote>
<p>除了可以免费注册域名以外，还有其他三种服务：</p>
</blockquote>
<ul>
<li>免费域名停放</li>
<li>免费短信</li>
<li>免费域名转发</li>
</ul>
<p><img src="https://img2.funning.top/file/5af131f8df9a55f33344a.png"></p>
]]></content>
      <categories>
        <category>域名</category>
        <category>免费</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
</search>
